<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Shadow of The Stony Peaks</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Gruvhub Theme Custom CSS */
        body {
            font-family: 'Cinzel', serif;
            background-image: url('https://i.postimg.cc/mDZs980Y/Gemini-Generated-Image-4h0rp14h0rp14h0r.png');
            background-size: contain;
            background-position: center;
            background-attachment: fixed;
            color: #e6d5b8; /* Parchment */
            background-repeat: no-repeat;
            background-color: #3a241d;
        }
        .gruvhub-bg {
            background-color: rgba(90, 61, 43, 0.95); /* Slightly transparent Leather Brown */
            box-shadow: 0 0 15px rgba(0,0,0,0.7); /* Deeper shadow for depth */
        }
        .gruvhub-border {
            border: 2px solid #c0a080; /* Tan Gold */
        }
        /* Adjusted input text size and padding for less cramping */
        .gruvhub-input, select.gruvhub-input {
            background-color: #e6d5b8; /* Parchment */
            border: 1px solid #c0a080; /* Tan Gold */
            color: #3a241d; /* Dark Wood Brown */
            font-size: 0.8rem; /* Smaller text inside inputs/selects */
            padding: 0.25rem 0.5rem; /* Reduced padding */
        }
        .gruvhub-input:focus {
            outline: none;
            border-color: #ffd700; /* Gold */
            box-shadow: 0 0 5px #ffd700;
        }
        .gruvhub-button {
            background-color: #4a2c2a; /* Dark Reddish Brown */
            color: #e6d5b8; /* Parchment */
            border: 1px solid #c0a080; /* Tan Gold */
            transition: all 0.2s ease-in-out;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 1px;
        }
        .gruvhub-button:hover {
            background-color: #7a504a; /* Slightly lighter hover */
            color: #ffd700;
            border-color: #ffd700;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.5); /* Added subtle glow */
        }
        .gruvhub-button:disabled {
            background-color: #3a2c2a;
            color: #8b7d6b;
            cursor: not-allowed;
        }
        .gruvhub-button.active, .tab-btn.active, .tool-btn.active {
            background-color: #a07a2c; /* Richer Gold/Brown active background */
            color: #fff;
            border-color: #f7d04d;
            box-shadow: 0 0 10px #f7d04d; /* Stronger glow for active state */
        }
        .map-tab {
            background-color: #4a2c2a;
            border: 1px solid #c0a080;
            border-bottom: none;
            padding: 4px 12px;
            margin-right: 4px;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }
        .map-tab:hover {
            background-color: #5a3d2b;
        }
        .map-tab.active {
            background-color: #6b4c4a;
            color: #ffd700;
            border-color: #ffd700;
            transform: translateY(2px);
        }
        .map-tab-delete {
            font-size: 16px;
            font-weight: bold;
            color: #c0a080;
            padding: 0 4px;
            border-radius: 50%;
            line-height: 1;
        }
        .map-tab-delete:hover {
            color: #fff;
            background-color: #a02c2a;
        }

        .map-token {
            cursor: grab;
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            user-select: none;
            font-size: 10px;
            color: white;
            border: 2px solid white;
            box-shadow: 0 0 10px rgba(0,0,0,0.7);
            overflow-wrap: break-word;
            padding: 2px;
            text-shadow: 1px 1px 2px black;
            background-size: cover;
            background-position: center;
        }
        .map-token:active {
            cursor: grabbing;
        }
        .fog-block {
            position: absolute;
            background-color: rgba(18, 12, 10, 0.9); /* Darker, mistier fog */
            border: 1px dashed #c0a080;
            backdrop-filter: blur(2px); /* Added slight blur for mist effect */
            cursor: pointer;
        }
        /* --- Map Container Styles --- */
        .map-container {
            border: 4px ridge #c0a080;
            position: relative;
            overflow: hidden; /* This is the viewport */
            width: 100%;
            height: 100%;
            cursor: move; /* Panning cursor */
            background-color: #3a241d;
        }
        #map-content {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0; /* Zoom originates from top-left */
            background-size: cover;
            background-position: center;
        }
        /* UPDATED CANVAS Z-INDEXES */
        #grid-canvas, #fow-canvas, #overlay-canvas { /* ADD fow-canvas and overlay-canvas */
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        #grid-canvas { z-index: 5; }
        #fow-canvas { z-index: 7; background-color: transparent; } /* NEW FOW Layer */
        #overlay-canvas { z-index: 8; } /* DM Drawing/Templates/Ruler */
        .map-token, .fog-block {
            z-index: 10;
        }
        .selected {
            border: 3px solid #ffd700 !important;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
            z-index: 20;
        }
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #ffd700;
            border: 1px solid #fff;
            z-index: 10;
        }
        .resize-handle.br {
            bottom: -5px;
            right: -5px;
            cursor: nwse-resize;
        }
        .status-effect-icon {
            position: absolute;
            font-size: 14px;
            width: 16px;
            height: 16px;
            line-height: 16px;
            text-shadow: 0 0 2px black;
        }
        .status-effect-btn.active {
            background-color: #ffd700;
            color: #3a241d;
        }
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #3a241d;
        }
        ::-webkit-scrollbar-thumb {
            background: #5a3d2b;
            border: 1px solid #c0a080;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #7a5d4b;
        }
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 500; /* CRITICAL FIX: Ensure modals are on top */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* --- Spell Effect Animations --- */
        .spell-effect {
            position: absolute;
            pointer-events: none;
            z-index: 50;
        }
        .spell-effect.on-battle {
            position: fixed;
            z-index: 250;
        }
        /* Existing effects */
        .effect-fireball { width: 120px; height: 120px; border-radius: 50%; background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,200,0,0.7) 40%, rgba(255,0,0,0.5) 80%); animation: fireball-animation 1s ease-out forwards; }
        @keyframes fireball-animation { 0% { transform: translate(-50%, -50%) scale(0); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(2.5); opacity: 0; } }
        .effect-slash { width: 120px; height: 120px; border-top: 4px solid rgba(255, 255, 255, 0.8); border-radius: 50%; animation: slash-animation 0.6s ease-out forwards; }
        @keyframes slash-animation { 0% { transform: translate(-50%, -50%) rotate(-60deg) scale(0.5); opacity: 1; } 100% { transform: translate(-50%, -50%) rotate(45deg) scale(2); opacity: 0; } }
        .effect-heal { width: 100px; height: 100px; border-radius: 50%; background-color: rgba(144, 238, 144, 0.5); box-shadow: 0 0 20px 10px rgba(144, 238, 144, 0.7); animation: heal-animation 1.2s ease-in-out forwards; }
        @keyframes heal-animation { 0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0; } }
        .effect-ice { width: 150px; height: 150px; background-image: radial-gradient(rgba(173, 216, 230, 0.5) 30%, transparent 31%), radial-gradient(rgba(255, 255, 255, 0.6) 30%, transparent 31%); background-size: 20px 20px, 10px 10px; background-position: 0 0, 5px 5px; border-radius: 50%; animation: ice-animation 1.2s forwards; }
        @keyframes ice-animation { 0% { transform: translate(-50%, -50%) scale(0); opacity: 1; } 80% { transform: translate(-50%, -50%) scale(1.8); opacity: 1; } 100% { opacity: 0; } }
        .effect-lightning { width: 40px; height: 150px; background: linear-gradient(to bottom, transparent, #9370DB, transparent); box-shadow: 0 0 10px #9370DB, 0 0 20px #9370DB; clip-path: polygon(50% 0, 60% 20%, 40% 40%, 55% 60%, 45% 80%, 50% 100%); animation: lightning-animation 0.8s ease-out forwards; }
        @keyframes lightning-animation { 0% { opacity: 0; transform: translate(-50%, -50%) scaleY(0.5); } 20% { opacity: 1; transform: translate(-50%, -50%) scaleY(1); } 80% { opacity: 1; } 100% { opacity: 0; } }
        /* NEW EFFECTS */
        .effect-drain { width: 100px; height: 100px; border-radius: 50%; background: radial-gradient(circle, rgba(100,0,100,0.8) 0%, rgba(50,0,50,0.6) 50%); box-shadow: 0 0 15px rgba(100,0,100,0.9); animation: drain-animation 1.5s ease-in-out forwards; }
        @keyframes drain-animation { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } 50% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 0; } }
        .effect-stun { width: 80px; height: 80px; background: radial-gradient(yellow, orange, transparent); clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); animation: stun-animation 0.5s linear infinite alternate; }
        @keyframes stun-animation { 0% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 0.8; } 100% { transform: translate(-50%, -50%) scale(1.1) rotate(15deg); opacity: 1; } }
        .effect-shield { width: 150px; height: 150px; border-radius: 50%; border: 6px solid rgba(173, 216, 230, 0.9); box-shadow: 0 0 25px rgba(173, 216, 230, 1); animation: shield-animation 1.5s ease-in-out infinite; }
        @keyframes shield-animation { 0% { transform: translate(-50%, -50%) scale(0.9); opacity: 0.8; } 50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(0.9); opacity: 0.8; } }
        /* NEW STATUS EFFECTS */
        .effect-poisoned-gas { width: 150px; height: 150px; border-radius: 50%; background: radial-gradient(circle, rgba(0,255,0,0.4) 0%, rgba(50,150,50,0.3) 50%, transparent 80%); animation: poison-gas-animation 2s linear infinite; }
        @keyframes poison-gas-animation { 0% { transform: translate(-50%, -50%) scale(0.8); } 100% { transform: translate(-50%, -50%) rotate(360deg) scale(1.2); } }
        .effect-arcane-buff { width: 100px; height: 100px; border-radius: 50%; background: radial-gradient(circle, rgba(135,206,250,0.6) 0%, rgba(255,0,255,0.4) 50%); animation: arcane-buff-animation 1s linear infinite alternate; }
        @keyframes arcane-buff-animation { 0% { transform: translate(-50%, -50%) scale(1) rotate(0deg); } 100% { transform: translate(-50%, -50%) scale(1.05) rotate(10deg); } }
        .effect-bleed { width: 50px; height: 50px; border-radius: 50%; background-color: rgba(255, 0, 0, 0.8); animation: bleed-animation 0.5s ease-in-out infinite alternate; }
        @keyframes bleed-animation { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0.5; } 100% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.9; } }


        /* Battle System Styles */
        #battle-screen {
            background: url('https://i.postimg.cc/4yhFHcN9/SSP-battle.png') no-repeat center center;
            background-size: cover;
            z-index: 200;
        }
        .combatant-card {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            border: 2px solid #c0a080;
            width: 150px;
            height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            border-radius: 8px;
            text-align: center;
            transition: all 0.3s ease;
            flex-shrink: 0; /* Ensures the card size is respected in scrolling container */
        }
        .combatant-card.active-turn {
            /* FIX 1: Removed transform: scale(1.1) to stabilize layout */
            border-color: #ffd700;
            box-shadow: 0 0 10px #ffd700; /* Set a base shadow */
            /* Added flashing effect for extra clarity */
            animation: pulse-turn 1.5s infinite alternate;
        }
        /* FIX 2: Modified animation to only change shadow intensity, not size/scale */
        @keyframes pulse-turn {
            0% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.7); }
            100% { box-shadow: 0 0 20px rgba(255, 215, 0, 1.0); }
        }

        .combatant-card.targetable {
            cursor: pointer;
            border-color: #ff4500;
        }
        .combatant-card.targetable:hover {
            box-shadow: 0 0 15px #ff4500;
            transform: scale(1.05);
        }
        .combatant-card.defeated {
            filter: grayscale(1);
            opacity: 0.5;
        }
        /* REMOVED: dimming non-active player cards */
        
        .combatant-image {
            width: 90px;
            height: 90px;
            background-size: cover;
            background-position: center;
            border-radius: 50%;
            border: 2px solid #fff;
            margin-bottom: 8px;
        }
        .combatant-health-bar {
            width: 100%;
            height: 10px;
            background-color: #555;
            border: 1px solid #333;
            border-radius: 5px;
            overflow: hidden;
        }
        .combatant-health-fill {
            height: 100%;
            background: linear-gradient(to right, #b91c1c, #ef4444);
            transition: width 0.5s ease-in-out;
        }
        .combatant-health-fill.high { background: linear-gradient(to right, #15803d, #22c55e); }
        .combatant-health-fill.medium { background: linear-gradient(to right, #ca8a04, #eab308); }
        /* Reduced font size for token bank tabs for better fit */
        .token-bank-tab {
            background-color: #4a2c2a;
            border: 1px solid #c0a080;
            border-bottom: none;
            padding: 2px 6px;
            border-radius: 4px 4px 0 0;
            font-size: 0.7rem; 
        }
        .token-bank-tab.active {
            background-color: #6b4c4a;
            color: #ffd700;
            transform: translateY(1px);
        }
        .status-effect-box {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 4px;
            border-radius: 4px;
            margin-top: 4px;
        }
        
        /* NEW: Active turn indicator border */
        .combatant-card.active-turn .combatant-image {
            border: 3px solid #ffd700;
            box-shadow: 0 0 8px #ffd700;
        }
        
        /* NEW: Ability Grid Layout */
        #ability-buttons-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
    </style>
</head>
<body class="overflow-hidden h-screen">
    <!-- Title Screen -->
    <div id="title-screen" class="fixed top-0 left-0 w-full h-full flex flex-col items-center justify-center hidden" style="background-image: url('https://i.postimg.cc/mDZs980Y/Gemini-Generated-Image-4h0rp14h0rp14h0r.png'); background-size: contain; background-position: center; z-index: 150; background-repeat: no-repeat; background-color: #3a241d;">
        <div class="text-center bg-black bg-opacity-50 p-8 rounded-lg">
            <h1 class="text-6xl font-bold text-white mb-8" style="font-family: 'Cinzel', serif;">The Shadow of The Stony Peaks</h1>
            <button id="start-session-btn" class="gruvhub-button rounded p-4 text-2xl">Start Session</button>
        </div>
    </div>

    <!-- Login Screen -->
    <div id="login-screen" class="modal-backdrop flex">
        <div class="gruvhub-bg gruvhub-border rounded-lg p-8 shadow-xl max-w-sm mx-auto flex flex-col gap-4">
            <h2 class="text-2xl font-bold text-center text-white">Join Session</h2>
            <p class="text-sm text-center text-gray-300">Enter a username to join the virtual tabletop.</p>
            <div>
                <label for="username-input" class="block text-xs uppercase mb-1">Username</label>
                <input type="text" id="username-input" class="gruvhub-input w-full rounded p-2 text-lg">
                <p id="login-error" class="text-red-400 text-xs mt-1 h-4"></p>
            </div>
            <button id="join-session-btn" class="gruvhub-button rounded p-3 w-full text-lg">Join</button>
        </div>
    </div>

    <!-- Main Application Container -->
    <div id="app" class="grid grid-cols-12 grid-rows-1 h-screen gap-4 p-4">
        <!-- Left Panel: Chat, Dice, Turn Tracker -->
        <div class="col-span-2 h-full flex flex-col gap-4">
            <!-- Info Panel -->
            <div class="gruvhub-bg gruvhub-border rounded-lg p-3">
                <h2 class="text-lg font-bold text-gray-200 pb-1">SSP</h2>
                <p class="text-xs text-gray-400 border-b border-[#c0a080] pb-2 mb-2">Created by Max Prebeg V4.36</p>
                <p class="text-xs"><strong>Username:</strong> <span id="usernameDisplay"></span></p>
                <p class="text-xs mt-1"><strong>Session ID:</strong> <span id="sessionIdDisplay"></span></p>
                <div class="mt-2">
                    <h3 class="text-xs font-bold uppercase">Active Users</h3>
                    <ul id="user-list" class="text-xs mt-1 space-y-1 max-h-24 overflow-y-auto">
                        <!-- User list will be populated here -->
                    </ul>
                </div>
            </div>
            
            <!-- Chat -->
            <div class="gruvhub-bg gruvhub-border rounded-lg p-3 flex flex-col flex-grow min-h-0">
                <div class="flex justify-between items-center border-b border-[#c0a080] pb-2 mb-2">
                    <h2 class="text-lg font-bold text-gray-200">Chat</h2>
                    <button id="clear-chat-btn" title="Clear Chat Log" class="dm-controls-wrapper text-xs text-[#c0a080] hover:text-white">Clear</button>
                </div>
                <div id="chat-messages" class="flex-grow overflow-y-auto pr-2 space-y-2"></div>
                <div class="mt-2 flex gap-2">
                    <!-- NEW VOICE CLIP BUTTON -->
                    <button id="voice-clip-btn" class="gruvhub-button rounded px-2 py-2 text-sm flex-shrink-0" title="Record and send voice message">üéôÔ∏è</button>
                    <!-- END NEW VOICE CLIP BUTTON -->

                    <input type="text" id="chat-input" placeholder="Message or /roll NdS+M..." class="gruvhub-input w-full rounded p-2 text-sm">
                    <button id="send-chat" class="gruvhub-button rounded px-4 py-2 text-sm">Send</button>
                </div>
            </div>

            <!-- Dice Roller -->
            <div class="gruvhub-bg gruvhub-border rounded-lg p-3">
                <h2 class="text-lg font-bold text-gray-200 border-b border-[#c0a080] pb-2 mb-2">Dice</h2>
                <div id="dice-buttons-container" class="grid grid-cols-4 gap-2 text-xs"> <!-- ADDED ID -->
                    <button data-die="d4" class="dice-roll-btn gruvhub-button rounded p-2">d4</button>
                    <button data-die="d6" class="dice-roll-btn gruvhub-button rounded p-2">d6</button>
                    <button data-die="d8" class="dice-roll-btn gruvhub-button rounded p-2">d8</button>
                    <button data-die="d10" class="dice-roll-btn gruvhub-button rounded p-2">d10</button>
                    <button data-die="d12" class="dice-roll-btn gruvhub-button rounded p-2">d12</button>
                    <button data-die="d20" class="dice-roll-btn gruvhub-button rounded p-2">d20</button>
                    <button data-die="d100" class="dice-roll-btn gruvhub-button rounded p-2 col-span-2">d100</button>
                </div>
            </div>

            <!-- Turn Tracker -->
            <div class="gruvhub-bg gruvhub-border rounded-lg p-3 flex flex-col min-h-0">
                <h2 class="text-lg font-bold text-gray-200 border-b border-[#c0a080] pb-2 mb-2">Turns</h2>
                <div id="turn-tracker-list" class="flex-grow overflow-y-auto space-y-1 pr-2"></div>
                <div class="mt-2 text-xs flex justify-center gap-2 dm-controls-wrapper">
                    <button id="prev-turn" class="gruvhub-button rounded px-3 py-1">Prev</button>
                    <button id="next-turn" class="gruvhub-button rounded px-3 py-1">Next</button>
                    <button id="reset-turn" class="gruvhub-button rounded px-3 py-1">Reset</button>
                </div>
                <div class="mt-2 flex gap-2 dm-controls-wrapper">
                    <input type="text" id="turn-tracker-input" placeholder="Add..." class="gruvhub-input w-full rounded p-2 text-sm">
                    <button id="add-to-tracker" class="gruvhub-button rounded px-4 py-2 text-sm">Add</button>
                </div>
            </div>
        </div>

        <!-- Center Panel: Map -->
        <div class="col-span-8 h-full flex flex-col">
            <div class="gruvhub-bg gruvhub-border rounded-lg p-3 flex flex-col flex-grow h-full">
                <div id="map-tabs-container" class="flex items-center border-b-2 border-[#c0a080] mb-2 pb-1 overflow-x-auto">
                    <!-- Tabs will be dynamically inserted here -->
                    <button id="add-map-btn" title="Add New Map" class="dm-controls-wrapper gruvhub-button rounded-md flex-shrink-0 w-8 h-8 ml-auto text-lg font-bold">+</button>
                </div>
                <div id="map-container" class="map-container flex-grow relative">
                    <div id="map-content">
                        <canvas id="grid-canvas"></canvas>
                        <canvas id="fow-canvas"></canvas> <!-- NEW FOW CANVAS FOR VISION MASK -->
                        <canvas id="overlay-canvas"></canvas> <!-- RENAMED DM DRAWING CANVAS -->
                        <!-- Tokens and Fog will be added here by JS -->
                    </div>
                </div>
            </div>
        </div>


        <!-- Right Panel: Controls & Journal -->
        <div class="col-span-2 h-full flex flex-col gap-4">
            <div class="gruvhub-bg gruvhub-border rounded-lg p-3 flex flex-col h-full">
                <div class="flex border-b border-[#c0a080] mb-2">
                    <button id="controls-tab-btn" class="tab-btn active gruvhub-button flex-1 rounded-t-lg rounded-b-none text-sm py-1">Controls</button>
                    <button id="journal-tab-btn" class="tab-btn gruvhub-button flex-1 rounded-t-lg rounded-b-none text-sm py-1">Journal</button>
                </div>

                <!-- Controls Tab Content -->
                <div id="controls-tab-content" class="flex flex-col gap-3 text-sm h-full overflow-y-auto pr-2">
                    
                    <!-- SHARED AUDIO LINK DISPLAY (Visible to ALL) -->
                    <div id="shared-audio-display" class="mt-2 p-2 gruvhub-bg rounded-lg border border-[#c0a080]">
                        <h4 class="font-bold text-xs">Shared Audio Link (Open in new tab)</h4>
                        <a id="current-audio-link" target="_blank" class="text-xs text-blue-400 truncate hover:text-blue-200 block" href="#">No audio link set.</a>
                    </div>
                    <div class="border-t border-[#c0a080] my-2"></div>
                    
                    <!-- DM CONTROLS WRAPPER (DM-only content starts here) -->
                    <div class="dm-controls-wrapper flex flex-col gap-3">
                        <h3 class="font-bold text-gray-300">Battle</h3>
                        <button id="start-battle-btn" class="gruvhub-button bg-red-900 hover:bg-red-800">Start Battle</button>
                        
                        <!-- NEW: Turn Duration Control -->
                        <div class="flex flex-col gap-1">
                            <label for="turn-duration-input" class="text-xs font-bold uppercase">Turn Duration (sec)</label>
                            <div class="flex gap-2 items-center">
                                <input type="number" id="turn-duration-input" min="10" max="300" value="60" class="gruvhub-input w-20 text-xs">
                                <button id="set-turn-duration-btn" class="gruvhub-button p-2 text-xs flex-grow">Set Default</button>
                            </div>
                        </div>
                        <!-- END NEW: Turn Duration Control -->

                        <div class="border-t border-[#c0a080] my-2"></div>
                        <div class="flex flex-col gap-2">
                            <label for="preset-map-select" class="text-xs font-bold uppercase">Preset Maps (for active map)</label>
                            <select id="preset-map-select" class="gruvhub-input w-full rounded p-2 text-xs"></select>
                            
                            <label for="map-url-input" class="text-xs font-bold uppercase mt-1">Set Active Map from URL</label>
                            <input type="text" id="map-url-input" placeholder="Paste map image URL..." class="gruvhub-input w-full rounded p-2 text-xs">
                            <button id="change-map-btn" class="gruvhub-button rounded p-2">Set Map</button>

                            <!-- MAP FILE CONTROLS -->
                            <div class="flex gap-2">
                                <label for="load-map-data-input" class="bg-blue-600 hover:bg-blue-500 text-white rounded p-2 gruvhub-button text-center cursor-pointer text-xs leading-5 flex-grow">Load Active Map (File)</label>
                                <!-- ACCEPT JSON AND IMAGE FILES -->
                                <input type="file" id="load-map-data-input" class="hidden" accept=".json,image/*">
                                <button id="save-active-map-btn" class="bg-yellow-600 hover:bg-yellow-500 text-white rounded p-2 gruvhub-button text-xs">Save Map JSON</button>
                            </div>
                            <!-- END MAP FILE CONTROLS -->


                            <label for="new-map-url-input" class="text-xs font-bold uppercase mt-1">Add Map to Presets</label>
                            <input type="text" id="new-map-url-input" placeholder="Paste map image URL..." class="gruvhub-input w-full rounded p-2 text-xs">
                            <button id="add-preset-map-btn" class="gruvhub-button rounded p-2">Add to List</button>
                            <div class="border-t border-[#c0a080] my-2"></div>
                        </div>
                        <div class="flex flex-col gap-2">
                            <h3 class="font-bold text-gray-300">Active Map & Grid Controls</h3>
                            <div class="flex items-center justify-between">
                                <label for="grid-toggle" class="text-xs font-bold uppercase">Show Grid</label>
                                <input type="checkbox" id="grid-toggle" class="gruvhub-input">
                            </div>
                            <label for="grid-size-input" class="text-xs font-bold uppercase mt-1">Grid Size (<span id="grid-size-display">50</span>px)</label>
                            <input type="range" id="grid-size-input" min="10" max="200" value="50" class="w-full">
                            <div class="flex items-center gap-2">
                                <label for="grid-color-input" class="text-xs font-bold uppercase">Grid Color</label>
                                <input type="color" id="grid-color-input" value="#FFFFFF" class="p-0 h-7 w-10 rounded border-none bg-transparent">
                            </div>
                            <button id="reset-view-btn" class="gruvhub-button rounded p-2 mt-1">Reset Pan/Zoom</button>
                            <div class="border-t border-[#c0a080] my-2"></div>
                        </div>
                        
                        <!-- Fog of War and Fog Blocks (Reworked to be functional) -->
                        <div class="flex items-center justify-between">
                            <label for="fow-toggle" class="text-xs font-bold uppercase">Enable Fog of War</label>
                            <input type="checkbox" id="fow-toggle" class="gruvhub-input">
                        </div>
                        <button id="add-fog-btn" class="gruvhub-button rounded p-2">Add Fog Block</button>
                        
                        <div class="border-t border-[#c0a080] my-2"></div>
                        
                        <!-- NEW: DM Drawing Controls -->
                        <div id="dm-drawing-controls" class="flex flex-col gap-2 border-b border-[#c0a080] pb-2">
                            <h4 class="font-bold text-xs uppercase text-gray-300">DM Drawing Tools</h4>
                            <div class="flex gap-2">
                                <button id="draw-tool-btn" data-tool="draw" class="tool-btn gruvhub-button flex-1 rounded p-2 text-base">‚úèÔ∏è Draw</button>
                                <button id="erase-tool-btn" data-tool="erase" class="tool-btn gruvhub-button flex-1 rounded p-2 text-base">üßº Erase</button>
                            </div>
                            <div class="flex items-center gap-2 mt-1">
                                <label for="drawing-color-input" class="text-xs font-bold uppercase">Color</label>
                                <input type="color" id="drawing-color-input" value="#ff0000" class="p-0 h-7 w-10 rounded border-none bg-transparent">
                                <label for="drawing-thickness-input" class="text-xs font-bold uppercase ml-2">Size (<span id="drawing-thickness-display">5</span>)</label>
                                <input type="range" id="drawing-thickness-input" min="2" max="30" value="5" class="w-full">
                            </div>
                            <button id="clear-drawing-btn" class="gruvhub-button bg-red-800 hover:bg-red-700 rounded p-2">Clear Drawings</button>
                        </div>
                        <!-- END NEW DM Drawing Controls -->
                        
                        <div class="border-t border-[#c0a080] my-2"></div>
                        
                        <h3 class="font-bold text-gray-300">Session Management</h3>
                        <div class="grid grid-cols-2 gap-2 mt-1">
                            <button id="sync-data-btn" class="bg-blue-800 hover:bg-blue-700 text-white rounded p-2 gruvhub-button">Sync to Cloud</button>
                            <button id="clear-all-btn" class="bg-red-800 hover:bg-red-700 text-white rounded p-2 gruvhub-button">Clear Data</button>
                        </div>
                        <div class="grid grid-cols-2 gap-2 mt-1">
                            <button id="save-data-file-btn" class="bg-green-800 hover:bg-green-700 text-white rounded p-2 gruvhub-button">Save to File</button>
                            <label for="load-data-file-input" class="bg-purple-800 hover:bg-purple-700 text-white rounded p-2 gruvhub-button text-center cursor-pointer text-xs leading-5">Load from File</label>
                            <input type="file" id="load-data-file-input" class="hidden" accept=".json">
                        </div>
                        <div class="border-t border-[#c0a080] my-2"></div>

                        <div id="spell-effects-panel" class="flex flex-col gap-2">
                            <h3 class="font-bold text-gray-300">Spell & Attack Effects</h3>
                            <div class="grid grid-cols-3 gap-1">
                                <button data-effect="fireball" class="effect-btn gruvhub-button text-xs p-1">Fireball</button>
                                <button data-effect="slash" class="effect-btn gruvhub-button text-xs p-1">Slash</button>
                                <button data-effect="heal" class="effect-btn gruvhub-button text-xs p-1">Heal</button>
                                <button data-effect="ice" class="effect-btn gruvhub-button text-xs p-1">Ice</button>
                                <button data-effect="lightning" class="effect-btn gruvhub-button text-xs p-1">Lightning</button>
                                <button data-effect="drain" class="effect-btn gruvhub-button text-xs p-1">Drain</button>
                                <button data-effect="stun" class="effect-btn gruvhub-button text-xs p-1">Stun</button>
                                <button data-effect="shield" class="effect-btn gruvhub-button text-xs p-1">Shield</button>
                                <button data-effect="poisoned-gas" class="effect-btn gruvhub-button text-xs p-1">Poison</button>
                                <button data-effect="arcane-buff" class="effect-btn gruvhub-button text-xs p-1">Buff</button>
                                <button data-effect="bleed" class="effect-btn gruvhub-button text-xs p-1">Bleed</button>
                            </div>
                        </div>
                        <div class="border-t border-[#c0a080] my-2"></div>
                        
                        <div id="spell-templates-panel" class="flex flex-col gap-2">
                            <h3 class="font-bold text-gray-300">Spell Templates</h3>
                            <div class="grid grid-cols-3 gap-1">
                                <button data-template="circle" class="template-btn gruvhub-button text-xs p-1">20' Circle</button>
                                <button data-template="cone" class="template-btn gruvhub-button text-xs p-1">15' Cone</button>
                                <button data-template="square" class="template-btn gruvhub-button text-xs p-1">30' Square</button>
                            </div>
                            <button id="clear-templates-btn" class="gruvhub-button rounded p-2 mt-1 text-xs">Clear Templates</button>
                        </div>
                        <div id="template-controls-panel" class="hidden flex-col gap-2 mt-2">
                            <h3 class="font-bold text-gray-300">Selected Template</h3>
                            <div class="flex items-center gap-2">
                                <label for="template-color-input" class="text-xs font-bold uppercase">Color</label>
                                <!-- Updated default color to rich gold/bronze -->
                                <input type="color" id="template-color-input" value="#D4AF37" class="p-0 h-7 w-10 rounded border-none bg-transparent">
                            </div>
                        </div>
                        <div class="border-t border-[#c0a080] my-2"></div>

                        <!-- DM CONTROLS FOR AUDIO LINK (URL input and broadcast buttons) -->
                        <div id="audio-dm-controls" class="flex flex-col gap-2">
                            <h3 class="font-bold text-gray-300">Set Audio Broadcast (DM)</h3>
                            
                            <input type="text" id="audio-url-input" placeholder="Paste Tabletop Audio URL..." class="gruvhub-input w-full rounded p-2 text-xs">
                            <button id="set-audio-broadcast-btn" class="gruvhub-button bg-blue-700 hover:bg-blue-600 p-2 text-xs">Broadcast Link</button>
                            <button id="clear-audio-broadcast-btn" class="gruvhub-button bg-red-700 hover:bg-red-600 p-2 text-xs mt-1">Clear Broadcast</button>
                        </div>
                        <div class="border-t border-[#c0a080] my-2"></div>
                        
                        <div class="flex flex-col gap-2">
                            <h3 class="font-bold text-gray-300">Token Bank</h3>
                            <div id="token-bank-tabs" class="flex"></div>
                            <div id="token-bank-content" class="grid grid-cols-4 gap-2">
                                <!-- Preset tokens will be rendered here by JS -->
                            </div>
                            <!-- TOKEN FILE CONTROLS -->
                            <div class="flex gap-2 mt-2">
                                <label for="load-token-data-input" class="bg-blue-600 hover:bg-blue-500 text-white rounded p-2 gruvhub-button text-center cursor-pointer text-xs leading-5 flex-grow">Load Presets (JSON)</label>
                                <input type="file" id="load-token-data-input" class="hidden" accept=".json">
                                <button id="save-token-presets-btn" class="bg-yellow-600 hover:bg-yellow-500 text-white rounded p-2 gruvhub-button text-xs">Save Presets</button>
                            </div>
                            <!-- END TOKEN FILE CONTROLS -->
                        </div>
                        <div class="border-t border-[#c0a080] my-2"></div>

                        <div class="flex flex-col gap-2">
                            <h3 class="font-bold text-gray-300">Token Creation</h3>
                            <input type="text" id="token-name-input" placeholder="Token Name..." class="gruvhub-input w-full rounded p-2 text-xs">
                            <input type="text" id="token-image-url-input" placeholder="Token Image URL..." class="gruvhub-input w-full rounded p-2 text-xs">
                            <div class="flex gap-1 mt-1">
                                <input type="color" id="token-color-input" value="#ff0000" class="p-0 h-9 w-10 rounded border-none bg-transparent" title="Fallback color if no image">
                                <button id="add-token-btn" class="gruvhub-button rounded p-2 flex-grow">Add Token</button>
                            </div>
                            <!-- Load/Save Active Token - ADDED WARNING HERE -->
                            <div id="active-token-file-controls" class="hidden flex-col gap-2 pt-2 border-t border-[#c0a080]">
                                <h4 class="font-bold text-gray-300 flex items-center justify-between">
                                    <span>Active Token File Tools</span>
                                    <span class="text-xs font-normal text-red-400 italic">Offline use only</span>
                                </h4>
                                <div class="flex gap-2">
                                    <label for="load-active-token-input" class="bg-blue-600 hover:bg-blue-500 text-white rounded p-2 gruvhub-button text-center cursor-pointer text-xs leading-5 flex-grow">Load Token Image (File)</label>
                                    <input type="file" id="load-active-token-input" class="hidden" accept="image/*">
                                    <button id="save-active-token-btn" class="bg-yellow-600 hover:bg-yellow-500 text-white rounded p-2 gruvhub-button text-xs">Save Token JSON</button>
                                </div>
                            </div>
                        </div>
                        <div class="border-t border-[#c0a080] my-2"></div>

                    </div>
                    <!-- End DM Controls Wrapper -->
                    
                    <!-- Elements visible to players -->
                    <div class="flex flex-col gap-2">
                        <h3 class="font-bold text-gray-300">Map Tools</h3>
                        <button id="ruler-tool-btn" data-tool="ruler" class="tool-btn gruvhub-button rounded p-2">Ruler</button>
                    </div>
                    <div class="border-t border-[#c0a080] my-2"></div>
                    
                    <div id="token-controls-panel">
                        <h3 class="font-bold text-gray-300 mb-2">Status Effects (No Token)</h3>
                        <div id="status-effects-container" class="grid grid-cols-4 gap-2 opacity-50 pointer-events-none">
                            <button data-status="poisoned" title="Poisoned" class="status-effect-btn gruvhub-button rounded p-1 text-base" disabled>üíÄ</button>
                            <button data-status="blessed" title="Blessed" class="status-effect-btn gruvhub-button rounded p-1 text-base" disabled>‚ú®</button>
                            <button data-status="burning" title="Burning" class="status-effect-btn gruvhub-button rounded p-1 text-base" disabled>üî•</button>
                            <button data-status="frozen" title="Frozen" class="status-effect-btn gruvhub-button rounded p-1 text-base" disabled>‚ùÑÔ∏è</button>
                            <button data-status="stunned" title="Stunned" class="status-effect-btn gruvhub-button rounded p-1 text-base" disabled>üòµ</button>
                            <button data-status="shielded" title="Shielded" class="status-effect-btn gruvhub-button rounded p-1 text-base" disabled>üõ°Ô∏è</button>
                            <button data-status="hidden" title="Hidden" class="status-effect-btn gruvhub-button rounded p-1 text-base" disabled>üëª</button>
                            <button data-status="frightened" title="Frightened" class="status-effect-btn gruvhub-button rounded p-1 text-base" disabled>üò®</button>
                        </div>
                    </div>
                </div>

                <!-- Journal Tab Content -->
                <div id="journal-tab-content" class="hidden flex-col h-full">
                    <div id="journal-list" class="flex-grow overflow-y-auto pr-2 space-y-2"></div>
                    <div class="mt-2 pt-2 border-t border-[#c0a080]">
                        <input type="text" id="journal-title-input" placeholder="Entry Title..." class="gruvhub-input w-full rounded p-2 text-sm mb-2">
                        <textarea id="journal-content-input" placeholder="Text content or Image URL..." class="gruvhub-input w-full rounded p-2 text-sm h-20 mb-2"></textarea>
                        <button id="add-journal-btn" class="gruvhub-button rounded p-2 w-full">Add Journal Entry</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Battle Screen -->
    <div id="battle-screen" class="fixed top-0 left-0 w-full h-full flex flex-col p-8 hidden">
        <div class="absolute top-4 right-4 dm-controls-wrapper hidden flex-col gap-2">
            <button id="resort-initiative-btn" class="gruvhub-button bg-yellow-800 hover:bg-yellow-700">Re-Sort Initiative</button>
            <button id="end-battle-btn" class="gruvhub-button bg-red-800 hover:bg-red-700">End Battle</button>
        </div>
        <!-- UPDATED TURN ORDER DISPLAY -->
        <div id="battle-turn-order" class="text-center text-white text-lg mb-4 p-2 bg-black bg-opacity-50 rounded-lg">Turn Order...</div>
        <!-- END UPDATED TURN ORDER DISPLAY -->
        
        <!-- Flex Container for Teams - min-h-0 prevents overgrowth -->
        <div class="flex-grow flex justify-between items-stretch min-h-0"> 
            <!-- Enemy Team - Scrolls when overflowing -->
            <div id="enemy-team" class="flex flex-col gap-4 items-start overflow-y-auto pr-2 max-h-full"></div> 
            
            <!-- Player Team - Scrolls when overflowing -->
            <div id="player-team" class="flex flex-col gap-4 items-end overflow-y-auto pl-2 max-h-full"></div> 
        </div>
        
        <!-- Fix: Ensure the whole action area gets minimum height (h-40) and is a flex container for its contents -->
        <div class="gruvhub-bg gruvhub-border rounded-lg p-4 mt-4 grid grid-cols-3 gap-4 h-40 flex-shrink-0">
            <div id="battle-log" class="col-span-2 overflow-y-auto text-sm pr-2"></div>
            <!-- FIX: Added flex-grow and overflow-y-auto to the internal action container to allow scrolling -->
            <div id="battle-action-menu" class="relative flex flex-col overflow-y-auto"> 
                <!-- Main actions and abilities will be rendered here by JS -->
            </div>
        </div>
        <div id="battle-end-message" class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden">
            <h2 class="text-6xl font-bold text-white"></h2>
        </div>
    </div>


    <!-- Modal for confirmation -->
    <div id="confirmation-modal" class="modal-backdrop hidden">
        <div class="gruvhub-bg gruvhub-border rounded-lg p-6 shadow-xl max-w-sm mx-auto">
            <h3 class="text-lg font-bold text-white mb-4" id="modal-title">Are you sure?</h3>
            <p class="text-sm text-gray-300 mb-6" id="modal-text">This action cannot be undone.</p>
            <div class="flex justify-end gap-4">
                <button id="modal-cancel-btn" class="gruvhub-button rounded px-4 py-2">Cancel</button>
                <button id="modal-confirm-btn" class="bg-red-700 hover:bg-red-600 text-white rounded px-4 py-2 gruvhub-button">Confirm</button>
            </div>
        </div>
    </div>
    
    <!-- Battle Setup Modal -->
    <div id="battle-setup-modal" class="modal-backdrop hidden">
        <div class="gruvhub-bg gruvhub-border rounded-lg p-6 shadow-xl w-full max-w-lg mx-auto flex flex-col">
            <h3 class="text-xl font-bold text-white mb-4">Setup Battle</h3>
            <p class="text-sm text-gray-300 mb-4">Select tokens for the battle. Unassigned tokens are enemies by default.</p>
            <div id="battle-setup-token-list" class="flex-grow space-y-2 overflow-y-auto max-h-96 pr-2 mb-4">
                <!-- Token list will be populated here -->
            </div>
            <div class="flex justify-end gap-4">
                <button id="battle-setup-cancel-btn" class="gruvhub-button rounded px-4 py-2">Cancel</button>
                <button id="roll-initiative-btn" class="gruvhub-button bg-yellow-700 hover:bg-yellow-600 rounded px-4 py-2">Roll Initiative</button>
                <button id="begin-combat-btn" class="bg-green-700 hover:bg-green-600 text-white rounded px-4 py-2 gruvhub-button">Begin Combat</button>
            </div>
        </div>
    </div>
    
    <!-- Stat Block Modal (UPDATED FOR NAME EDITING) -->
    <div id="stat-block-modal" class="modal-backdrop hidden">
        <div class="gruvhub-bg gruvhub-border rounded-lg p-6 shadow-xl w-full max-w-md mx-auto overflow-y-auto max-h-[90vh]">
            <!-- Updated Header with Editable Name Input -->
            <div class="flex justify-between items-start mb-4">
                <div class="flex-grow">
                    <label for="stat-block-name-input" class="block text-xs uppercase mb-1 text-gray-400">Token Name</label>
                    <!-- Input field for the token name -->
                    <input type="text" id="stat-block-name-input" class="gruvhub-input text-xl font-bold w-full rounded p-1" disabled>
                </div>
                <button id="stat-block-close-btn" class="text-2xl text-[#c0a080] hover:text-white ml-4">&times;</button>
            </div>
            <!-- End Updated Header -->
            <div class="space-y-4 text-sm">
                <div class="grid grid-cols-4 gap-4"> <!-- Changed grid to 4 columns to fit Vision -->
                    <div>
                        <label for="stat-block-hp" class="block text-xs uppercase">Current HP</label>
                        <input type="number" id="stat-block-hp" class="gruvhub-input w-full rounded p-2">
                    </div>
                    <div>
                        <label for="stat-block-max-hp" class="block text-xs uppercase">Max HP</label>
                        <input type="number" id="stat-block-max-hp" class="gruvhub-input w-full rounded p-2">
                    </div>
                    <div>
                        <label for="stat-block-ac" class="block text-xs uppercase">Armor Class</label>
                        <input type="number" id="stat-block-ac" class="gruvhub-input w-full rounded p-2">
                    </div>
                    <!-- ADDED VISION RANGE INPUT -->
                    <div>
                        <label for="stat-block-vision-range" class="block text-xs uppercase">Vision (ft)</label>
                        <input type="number" id="stat-block-vision-range" class="gruvhub-input w-full rounded p-2">
                    </div>
                    <!-- END ADDED VISION RANGE INPUT -->
                </div>
                <div>
                    <label for="stat-block-notes" class="block text-xs uppercase">Notes</label>
                    <textarea id="stat-block-notes" rows="3" class="gruvhub-input w-full rounded p-2"></textarea>
                </div>
                <div id="stat-block-owner-wrapper">
                    <label for="stat-block-owner" class="block text-xs uppercase">Owner</label>
                    <select id="stat-block-owner" class="gruvhub-input w-full rounded p-2"></select>
                </div>
                <div class="border-t border-[#c0a080] my-2"></div>
                <div id="stat-block-abilities-wrapper">
                    <h4 class="font-bold text-gray-300 mb-2 flex justify-between items-center">
                        <span>Abilities</span>
                        <!-- NEW DM ABILITY LIBRARY BUTTON -->
                        <button id="open-ability-library-btn" class="gruvhub-button text-xs p-1">Load Preset</button>
                    </h4>
                    <div id="stat-block-abilities-list" class="space-y-2"></div>
                    <div class="mt-2 p-2 border border-[#c0a080] rounded">
                        <h5 class="font-bold text-gray-400 text-xs mb-1">Add Custom Ability</h5>
                        <input type="text" id="ability-name" placeholder="Ability Name" class="gruvhub-input w-full text-xs p-1 mb-1">
                        <div class="flex gap-2 mb-1">
                            <input type="number" id="ability-level" placeholder="Lvl (1-10)" class="gruvhub-input w-1/3 text-xs p-1">
                            <select type="number" id="ability-type" class="gruvhub-input w-2/3 text-xs p-1">
                                <option value="attack">Attack</option>
                                <option value="splash">Splash Attack</option>
                                <option value="heal">Heal</option>
                                <option value="dot">Damage over Time (DoT)</option>
                                <option value="hot">Heal over Time (HoT)</option>
                                <option value="status">Apply Status Effect</option>
                            </select>
                        </div>
                        
                        <input type="number" id="ability-hitchance" placeholder="Hit % (for attacks/status)" class="gruvhub-input w-full text-xs p-1 mb-1">
                        <select id="ability-animation" class="gruvhub-input w-full text-xs p-1 mb-1">
                            <option value="">No Animation</option>
                            <option value="slash">Slash</option>
                            <option value="fireball">Fireball</option>
                            <option value="heal">Heal</option>
                            <option value="ice">Ice</option>
                            <option value="lightning">Lightning</option>
                            <option value="drain">Drain</option>
                            <option value="stun">Stun</option>
                            <option value="shield">Shield</option>
                            <option value="poisoned-gas">Poison Gas</option>
                            <option value="arcane-buff">Arcane Buff</option>
                            <option value="bleed">Bleed</option>
                        </select>
                        <select id="ability-status-select" class="gruvhub-input w-full text-xs p-1 mb-1 hidden">
                            <option value="">-- Select Status Effect --</option>
                            <option value="poisoned">Poisoned (üíÄ)</option>
                            <option value="blessed">Blessed (‚ú®)</option>
                            <option value="burning">Burning (üî•)</option>
                            <option value="frozen">Frozen (‚ùÑÔ∏è)</option>
                            <option value="stunned">Stunned (üòµ)</option>
                            <option value="shielded">Shielded (üõ°Ô∏è)</option>
                            <option value="hidden">Hidden (üëª)</option>
                            <option value="frightened">Frightened (üò®)</option>
                        </select>
                        <div class="flex gap-1">
                            <input type="number" id="ability-damage-min" placeholder="Min Dmg/Heal/Tick" class="gruvhub-input w-1/2 text-xs p-1">
                            <input type="number" id="ability-damage-max" placeholder="Max Dmg/Heal/Tick" class="gruvhub-input w-1/2 text-xs p-1">
                        </div>
                        <input type="number" id="ability-duration" placeholder="Duration (Turns)" class="gruvhub-input w-full text-xs p-1 mt-1">
                        <button id="add-ability-btn" class="gruvhub-button text-xs p-1 mt-2 w-full">Add Ability</button>
                    </div>
                </div>
                <div class="text-right mt-4">
                    <button id="stat-block-save-btn" class="gruvhub-button rounded px-6 py-2">Save</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- NEW: DM Ability Library Modal -->
    <div id="ability-library-modal" class="modal-backdrop hidden">
        <div class="gruvhub-bg gruvhub-border rounded-lg p-6 shadow-xl w-full max-w-2xl mx-auto flex flex-col max-h-[90vh]">
            <div class="flex justify-between items-center border-b border-[#c0a080] pb-2 mb-4">
                <h3 class="text-xl font-bold text-white">DM Ability Library (Tiered)</h3>
                <button id="ability-library-close-btn" class="text-2xl text-[#c0a080] hover:text-white">&times;</button>
            </div>
            
            <div class="flex mb-4 gap-3 items-center">
                <label class="text-xs uppercase">Filter by Level:</label>
                <select id="ability-library-level-filter" class="gruvhub-input w-32">
                    <option value="0">All Levels</option>
                    <option value="1">Level 1 (Basic)</option>
                    <option value="2">Level 2</option>
                    <option value="3">Level 3</option>
                    <option value="4">Level 4</option>
                    <option value="5">Level 5 (Mid-Tier)</option>
                    <option value="6">Level 6</option>
                    <option value="7">Level 7</option>
                    <option value="8">Level 8</option>
                    <option value="9">Level 9</option>
                    <option value="10">Level 10 (Epic)</option>
                </select>
                <input type="text" id="ability-library-search" placeholder="Search by name..." class="gruvhub-input flex-grow">
            </div>

            <div id="ability-library-list" class="flex-grow overflow-y-auto space-y-3 pr-2">
                <!-- Abilities will be rendered here by JS -->
            </div>
        </div>
    </div>
    <!-- END DM Ability Library Modal -->

    <!-- Modal for Voice Recording -->
    <div id="voice-recording-modal" class="modal-backdrop hidden">
        <div class="gruvhub-bg gruvhub-border rounded-lg p-6 shadow-xl max-w-xs mx-auto text-center">
            <h3 id="voice-modal-title" class="text-lg font-bold text-white mb-4">Recording Voice Clip...</h3>
            <p id="voice-modal-message" class="text-sm text-gray-300 mb-4">Speak now (max 10 seconds).</p>
            <div id="voice-controls" class="flex justify-center gap-4">
                <button id="stop-record-btn" class="gruvhub-button bg-green-700 hover:bg-green-600 rounded px-4 py-2">Stop & Send</button>
                <button id="cancel-record-btn" class="gruvhub-button bg-red-700 hover:bg-red-600 rounded px-4 py-2">Cancel</button>
            </div>
        </div>
    </div>


    <!-- Firebase SDK -->
    <script type="module">
        // --- Firebase Imports and Configuration ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, updateDoc, getDoc, collection, serverTimestamp, query } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js";

        // --- Global State & Constants ---
        // FIX: Using the user's provided config for the local fallback and creating a safe variable for the auth token
        const fallbackConfig = {
            apiKey: "AIzaSyANkVaoKLvJmDqkKFJLQEKtv68qpDhHXdk",
            authDomain: "tabletop-14743.firebaseapp.com",
            projectId: "tabletop-14743",
            storageBucket: "tabletop-14743.firebasestorage.app",
            messagingSenderId: "798645102897",
            appId: "1:798645102897:web:f7dab152a31896c779a810",
            measurementId: "G-1V3J132291"
        };
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : fallbackConfig;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-vtt-session';
        
        // CRITICAL FIX: Safely assign __initial_auth_token to a local variable
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        const DM_PLAYER_GMPC_ID = 'dm-player-gmpc-id'; // Unique ID for DM-controlled player characters

        // --- Firebase Initialization (SINGLETON) ---
        let db, auth, analytics, vttDocRef;
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            analytics = getAnalytics(app);
            vttDocRef = doc(db, `artifacts/${appId}/public/data/vtt_state`, 'singleton_doc');
        } catch (e) {
            console.error("Firebase Initialization Failed:", e);
            document.body.innerHTML = `<div class="text-red-400 text-center p-8">FATAL ERROR: Could not connect to the session database.</div>`;
            throw new Error("Firebase init failed");
        }

        let userId = null;
        let isDM = false;
        let currentUsername = '';
        let usersCollectionRef;
        let activeUserList = []; // Initialized as empty array
        let vttState = {};
        let selectedElement = null;
        let armedEffect = null;
        let activeTokenCategory = 'Players';
        
        // Voice Recording State
        let mediaRecorder = null;
        let audioChunks = [];
        let recordingTimeout = null;

        // Battle State
        let battleActionState = { step: 'main', selectedAbility: null };
        let battleTimerInterval = null; // NEW: Timer interval handler

        // Tool State
        let activeTool = 'pan'; // 'pan', 'ruler', 'template', 'draw', 'erase'
        let rulerState = { active: false, start: null, end: null };
        let activeTemplateShape = null;
        let canvasInteraction = { active: false, type: null, targetId: null, handle: null, startPos: null, startDims: null };
        
        // Drawing State (NEW)
        let isDrawing = false;
        let currentLine = null;
        
        // Panning State
        let isPanning = false;
        let lastPanPoint = { x: 0, y: 0 };
        
        let fowCanvas, fowCtx; // NEW FOW CANVAS VARIABLES
        let overlayCanvas, overlayCtx; // RENAMED Drawing Canvas Variables
        
        const STATUS_ICONS = {
            poisoned: 'üíÄ', blessed: '‚ú®', burning: 'üî•', frozen: '‚ùÑÔ∏è',
            stunned: 'üòµ', shielded: 'üõ°Ô∏è', hidden: 'üëª', frightened: 'üò®'
        };
        
        // DM Screenshare content removed from here.

        const DEFAULT_STATE = {
            maps: [{
                id: 'default-map-1',
                name: 'My First Map',
                url: 'https://placehold.co/1200x800/5a3d2b/e6d5b8?text=Your+Battlemap',
                width: 1200,
                height: 800,
                transform: { scale: 1, panX: 0, panY: 0 },
                tokens: [],
                fogBlocks: [],
                grid: { enabled: false, size: 50, color: '#FFFFFF' },
                spellTemplates: [],
                // NEW: Drawing data
                drawing: {
                    lines: [], 
                    color: '#ff0000',
                    thickness: 5,
                },
                fowEnabled: true, // NEW: FoW toggle state
            }], 
            activeMapId: 'default-map-1',
            presetMaps: [
                { name: 'SSP Overworld', url: 'https://i.postimg.cc/R0N8x258/SSP-overworld.png' },
                { name: 'SSP Route 1', url: 'https://i.postimg.cc/L8rkhWgk/SSP-route1.png' },
                { name: 'SSP Oakhaven', url: 'https://i.postimg.cc/RVhwdm7r/SSP-Oakhaven.png' },
                { name: 'SSP Silvercreek', url: 'https://i.postimg.cc/6QrZqpXd/SSP-Silvercreek.png' },
                { name: 'SSP Manor', url: 'https://i.postimg.cc/G9nr4drC/SSP-Manor.png' },
                { name: 'SSP Dungeon 1', url: 'https://i.postimg.cc/QtBH5NL1/SSP-dungeon1.png' },
                { name: 'SSP Dungeon 2', url: 'https://i.postimg.cc/7Zxh9n88/SSP-dungeon2.png' },
                { name: 'SSP Dungeon Basement', url: 'https://i.postimg.cc/HLNLpGJH/SSP-dungeon-Basement.png' },
                { name: 'SSP Tavern', url: 'https://i.postimg.cc/J4RRC7Tg/SSP-tavern.png' }
            ],
            presetTokens: {
                Players: [
                    { name: 'Mage', url: 'https://i.postimg.cc/Y94xdmL7/SSP-P-Mage.png', abilities: [
                        { name: 'Arcane Bolt', type: 'attack', animation: 'fireball', hitChance: 70, damageRange: [3, 8], level: 1 },
                        { name: 'Frost Barrier', type: 'status', animation: 'shield', hitChance: 90, duration: 2, statusName: 'shielded', level: 2 },
                        { name: 'Arcane Burn (DoT)', type: 'dot', animation: 'burning', hitChance: 60, damageRange: [4, 7], duration: 3, level: 4, statusName: 'Burning' },
                        { name: 'Mana Shield (HoT)', type: 'hot', animation: 'arcane-buff', hitChance: 100, damageRange: [2, 4], duration: 4, level: 5, statusName: 'Mana Shield' },
                        { name: 'Chain Lightning', type: 'splash', animation: 'lightning', hitChance: 65, damageRange: [8, 15], level: 7 },
                        { name: 'Teleport Strike', type: 'attack', animation: 'lightning', hitChance: 85, damageRange: [12, 20], level: 8 },
                        { name: 'Meteor', type: 'splash', animation: 'fireball', hitChance: 50, damageRange: [20, 40], level: 10 },
                    ]},
                    { name: 'Fighter', url: 'https://i.postimg.cc/Wzwq828s/SSP-P-Fighter.png', abilities: [
                        { name: 'Basic Melee', type: 'attack', animation: 'slash', hitChance: 85, damageRange: [5, 10], level: 1 },
                        { name: 'Defensive Stance', type: 'status', animation: 'shield', hitChance: 100, duration: 2, statusName: 'shielded', level: 2 },
                        { name: 'Cleave (Splash)', type: 'splash', animation: 'slash', hitChance: 75, damageRange: [7, 12], level: 3 },
                        { name: 'Puncture (Bleed)', type: 'dot', animation: 'bleed', hitChance: 70, damageRange: [2, 3], duration: 5, level: 4, statusName: 'Bleeding' },
                        { name: 'Stunning Blow', type: 'status', animation: 'stun', hitChance: 50, duration: 1, statusName: 'stunned', level: 6 },
                        { name: 'Execute', type: 'attack', animation: 'slash', hitChance: 95, damageRange: [15, 25], level: 8 },
                    ]},
                    { name: 'Archer', url: 'https://i.postimg.cc/65HypbmN/SSP-P-Archer.png', abilities: [
                        { name: 'Standard Shot', type: 'attack', animation: 'slash', hitChance: 80, damageRange: [4, 9], level: 1 },
                        { name: 'Poison Arrow', type: 'dot', animation: 'poisoned-gas', hitChance: 60, damageRange: [2, 4], duration: 3, level: 3, statusName: 'poisoned' },
                        { name: 'Crippling Shot', type: 'dot', animation: 'bleed', hitChance: 65, damageRange: [1, 2], duration: 4, level: 3, statusName: 'Wound' },
                        { name: 'Ice Arrow', type: 'status', animation: 'ice', hitChance: 55, duration: 2, statusName: 'frozen', level: 5 },
                        { name: 'Volley (Splash)', type: 'splash', animation: 'slash', hitChance: 70, damageRange: [6, 11], level: 7 },
                    ]},
                    { name: 'Healer', url: 'https://i.postimg.cc/xdmCgfT9/SSP-P-Healer.png', abilities: [
                        { name: 'Minor Heal', type: 'heal', animation: 'heal', healRange: [5, 10], level: 1 },
                        { name: 'Divine Smite', type: 'attack', animation: 'shield', hitChance: 75, damageRange: [6, 12], level: 2 },
                        { name: 'Blessing', type: 'status', animation: 'blessed', hitChance: 100, duration: 3, statusName: 'blessed', level: 2 },
                        { name: 'Healing Aura (HoT)', type: 'hot', animation: 'heal', hitChance: 100, damageRange: [3, 5], duration: 3, level: 4, statusName: 'Healing Aura' },
                        { name: 'Purify (Heal)', type: 'heal', animation: 'heal', healRange: [15, 25], level: 6 },
                    ]},
                    { name: 'Bard', url: 'https://i.postimg.cc/GtXh99zK/SSP-P-Bard.png', abilities: [
                        { name: 'Vicious Mockery', type: 'attack', animation: 'drain', hitChance: 70, damageRange: [1, 4], level: 1 },
                        { name: 'Bardic Inspiration', type: 'status', animation: 'arcane-buff', hitChance: 100, duration: 2, statusName: 'blessed', level: 2 },
                        { name: 'Shattering Note', type: 'splash', animation: 'ice', hitChance: 60, damageRange: [5, 10], level: 3 },
                    ]},
                    { name: 'Goof', url: 'https://i.postimg.cc/fT3hYHRC/SSP-P-Goof.png', abilities: [
                        { name: 'Slap', type: 'attack', animation: 'slash', hitChance: 90, damageRange: [1, 2], level: 1 },
                        { name: 'Trip (Stun)', type: 'status', animation: 'stun', hitChance: 40, duration: 1, statusName: 'stunned', level: 2 },
                    ]},
                    { name: 'Spellcaster', url: 'https://i.postimg.cc/MKsgWSg2/SSP-P-Spellcaster.png', abilities: [
                        { name: 'Magic Missile', type: 'attack', animation: 'fireball', hitChance: 100, damageRange: [1, 5], level: 1 },
                        { name: 'Telekinetic Push', type: 'attack', animation: 'drain', hitChance: 60, damageRange: [5, 10], level: 3 },
                    ]},
                    { name: 'Druid', url: 'https://i.postimg.cc/Wz5YbGWg/SSP-P-Druid.png', abilities: [
                        { name: 'Thorn Whip', type: 'attack', animation: 'slash', hitChance: 75, damageRange: [3, 6], level: 1 },
                        { name: 'Healing Word (HoT)', type: 'hot', animation: 'heal', hitChance: 100, damageRange: [2, 5], duration: 3, level: 3, statusName: 'Regrowth' },
                        { name: 'Poison Spores (DoT)', type: 'dot', animation: 'poisoned-gas', hitChance: 55, damageRange: [4, 8], duration: 4, level: 5, statusName: 'Poison' },
                    ]},
                    { name: 'Drunk', url: 'https://i.postimg.cc/VvfH8GRr/SSP-P-Drunk.png', abilities: [
                        { name: 'Wild Swing', type: 'attack', animation: 'slash', hitChance: 60, damageRange: [8, 14], level: 1 },
                        { name: 'Swig Ale (HoT)', type: 'hot', animation: 'heal', hitChance: 100, damageRange: [1, 2], duration: 10, level: 2, statusName: 'Ale Buff' },
                        { name: 'Belch (Stun)', type: 'status', animation: 'stun', hitChance: 30, duration: 1, statusName: 'stunned', level: 3 },
                    ]},
                    { name: 'Monk', url: 'https://i.postimg.cc/8cZXPRKd/SSP-P-Monk.png', abilities: [
                        { name: 'Flurry of Blows', type: 'attack', animation: 'slash', hitChance: 90, damageRange: [2, 5], level: 1 },
                        { name: 'Stunning Fist', type: 'status', animation: 'stun', hitChance: 60, duration: 1, statusName: 'stunned', level: 4 },
                        { name: 'Evasion (Shield)', type: 'status', animation: 'shield', hitChance: 100, duration: 1, statusName: 'shielded', level: 5 },
                    ]},
                ],
                NPCs: [
                    { name: 'Mayor Thornton', url: 'https://i.postimg.cc/631m3XnL/SSP-N-Mayor-Thornton.png', abilities: [
                        { name: 'Faint', type: 'status', animation: 'stun', hitChance: 100, duration: 1, statusName: 'stunned', level: 1 },
                        { name: 'Bribe (Status)', type: 'status', animation: 'blessed', hitChance: 5, duration: 1, statusName: 'stunned', level: 1 },
                    ]},
                    { name: 'Pip the Bartender', url: 'https://i.postimg.cc/J7s1Q7TQ/SSP-N-Pip-the-Halfling-Bartender.png', abilities: [
                        { name: 'Serve Ale (Heal)', type: 'heal', animation: 'heal', healRange: [3, 8], level: 1 },
                        { name: 'Bar Brawl (Attack)', type: 'attack', animation: 'slash', hitChance: 70, damageRange: [4, 7], level: 2 },
                    ]},
                    { name: 'Linnea the Herbalist', url: 'https://i.postimg.cc/BZRJ7Wk3/SSP-N-Linnea-the-Herbalist.png', abilities: [
                        { name: 'Minor Poison (DoT)', type: 'dot', animation: 'poisoned-gas', hitChance: 60, damageRange: [1, 2], duration: 4, level: 2, statusName: 'poisoned' },
                        { name: 'Herbal Poultice (Heal)', type: 'heal', animation: 'heal', healRange: [8, 15], level: 3 },
                    ]},
                    { name: 'Elara the Smith', url: 'https://i.postimg.cc/4NtsrLRp/SSP-N-Elara-the-Smith.png', abilities: [
                        { name: 'Hammer Strike', type: 'attack', animation: 'slash', hitChance: 70, damageRange: [10, 18], level: 3 },
                        { name: 'Blacksmith Aura (HoT)', type: 'hot', animation: 'shield', hitChance: 100, damageRange: [1, 3], duration: 99, level: 5, statusName: 'Smith Aura' },
                        { name: 'Weld (Heal)', type: 'heal', animation: 'heal', healRange: [8, 15], level: 4 },
                    ]},
                    { name: 'Rune', url: 'https://i.postimg.cc/vm48tXFP/SSP-N-Rune.png', abilities: [
                        { name: 'Dodge', type: 'status', animation: 'hidden', hitChance: 100, duration: 1, statusName: 'hidden', level: 4 },
                        { name: 'Sneak Attack', type: 'attack', animation: 'slash', hitChance: 90, damageRange: [8, 15], level: 5 },
                    ]},
                    { name: 'Merchant', url: 'https://i.postimg.cc/MpKpvqsB/SSP-N-Merchant.png', abilities: [
                        { name: 'Beg', type: 'status', animation: 'frightened', hitChance: 5, duration: 1, statusName: 'frightened', level: 1 },
                    ]},
                    { name: 'Hag\'s Hut', url: 'https://i.postimg.cc/BvRSYDJX/SSP-N-Hags-Hut.png', abilities: [
                        { name: 'Witch Bolt', type: 'attack', animation: 'lightning', hitChance: 60, damageRange: [12, 20], level: 6 },
                        { name: 'Curse (DoT)', type: 'dot', animation: 'drain', hitChance: 70, damageRange: [5, 10], duration: 3, level: 7, statusName: 'Cursed' },
                    ]},
                    { name: 'Story NPC', url: 'https://i.postimg.cc/B6cwR92C/SSP-Storyz-1.webp', abilities: [
                        { name: 'Inspirational Speech', type: 'status', animation: 'blessed', hitChance: 100, duration: 3, statusName: 'blessed', level: 3 },
                    ]},
                    { name: 'Bandit Leader', url: 'https://i.postimg.cc/Jz4zGMTy/SSP-N-Banditleader.png', abilities: [
                        { name: 'Vicious Strike', type: 'attack', animation: 'slash', hitChance: 80, damageRange: [8, 14], level: 4 },
                        { name: 'Throw Net (Stun)', type: 'status', animation: 'stun', hitChance: 55, duration: 1, statusName: 'stunned', level: 4 },
                        { name: 'Call Reinforcements', type: 'status', animation: 'arcane-buff', hitChance: 100, duration: 1, statusName: 'hidden', level: 5 },
                    ]},
                    { name: 'Altar', url: 'https://i.postimg.cc/YSv2z8B0/SSP-N-Alter.png', abilities: [
                        { name: 'Divine Blessing', type: 'hot', animation: 'heal', hitChance: 100, damageRange: [5, 15], duration: 99, level: 6, statusName: 'Divine Aura' },
                    ]},
                    { name: 'Lich Boss', url: 'https://i.postimg.cc/KjGs2qN8/SSP-N-Lich-Boss.png', abilities: [
                        { name: 'Death Bolt', type: 'attack', animation: 'drain', hitChance: 75, damageRange: [20, 35], level: 7 },
                        { name: 'Drain Life', type: 'dot', animation: 'drain', hitChance: 85, damageRange: [5, 10], duration: 3, level: 7, statusName: 'Draining' },
                        { name: 'Mass Fear', type: 'status', animation: 'frightened', hitChance: 70, duration: 2, statusName: 'frightened', level: 8 },
                        { name: 'Lich Regeneration (HoT)', type: 'hot', animation: 'heal', hitChance: 100, damageRange: [10, 15], duration: 99, level: 9, statusName: 'Regeneration' },
                    ]},
                ],
                Monsters: [
                    { name: 'Wolves', url: 'https://i.postimg.cc/TwW4ps9g/SSP-N-Wolfs.png', abilities: [
                        { name: 'Bite', type: 'attack', animation: 'slash', hitChance: 75, damageRange: [4, 7], level: 1 },
                        { name: 'Snarl (Fear)', type: 'status', animation: 'frightened', hitChance: 60, duration: 2, statusName: 'frightened', level: 2 },
                        { name: 'Pack Attack', type: 'attack', animation: 'slash', hitChance: 85, damageRange: [6, 10], level: 3 },
                    ]},
                    { name: 'Goblin', url: 'https://i.postimg.cc/qRd8xZrZ/SSP-N-Goblin.png', abilities: [
                        { name: 'Stab', type: 'attack', animation: 'slash', hitChance: 70, damageRange: [3, 5], level: 1 },
                        { name: 'Hide', type: 'status', animation: 'hidden', hitChance: 100, duration: 1, statusName: 'hidden', level: 1 },
                    ]},
                    { name: 'Goblin Pack', url: 'https://i.postimg.cc/qM72w3PY/SSP-N-Goblin-Pack.png', abilities: [
                        { name: 'Coordinated Stab', type: 'attack', animation: 'slash', hitChance: 75, damageRange: [5, 9], level: 2 },
                    ]},
                    { name: 'Goblin Group', url: 'https://i.postimg.cc/43c6tRDx/SSP-N-Group.png', abilities: [
                        { name: 'Mass Attack', type: 'splash', animation: 'slash', hitChance: 60, damageRange: [4, 8], level: 3 },
                    ]},
                    { name: 'Swamp Ghouls', url: 'https://i.postimg.cc/C5Gr4f9v/SSP-N-Swamp-Ghouls.png', abilities: [
                        { name: 'Claw', type: 'attack', animation: 'slash', hitChance: 65, damageRange: [6, 11], level: 3 },
                        { name: 'Poison Spit', type: 'dot', animation: 'poisoned-gas', hitChance: 50, damageRange: [3, 5], duration: 3, level: 4, statusName: 'poisoned' },
                    ]},
                    { name: 'Ogre', url: 'https://i.postimg.cc/50vxZ0th/SSP-N-Ogre.png', abilities: [
                        { name: 'Club Smash', type: 'attack', animation: 'slash', hitChance: 60, damageRange: [15, 25], level: 5 },
                        { name: 'Ground Stomp', type: 'splash', animation: 'stun', hitChance: 50, damageRange: [5, 10], level: 6 },
                    ]},
                    { name: 'Gnarly Treant', url: 'https://i.postimg.cc/FKwrWchS/SSP-N-Gnarly-Treant.png', abilities: [
                        { name: 'Root Grab (Stun)', type: 'status', animation: 'stun', hitChance: 70, duration: 2, statusName: 'stunned', level: 4 },
                        { name: 'Branch Lash', type: 'attack', animation: 'slash', hitChance: 85, damageRange: [10, 18], level: 5 },
                    ]},
                    { name: 'Boar', url: 'https://i.postimg.cc/sgDgvsn1/SSP-N-Boar.png', abilities: [
                        { name: 'Tusk Gore', type: 'attack', animation: 'slash', hitChance: 80, damageRange: [7, 12], level: 2 },
                    ]},
                    { name: 'Spider', url: 'https://i.postimg.cc/prW1HGZV/SSP-N-Spider.png', abilities: [
                        { name: 'Bite', type: 'attack', animation: 'slash', hitChance: 75, damageRange: [3, 6], level: 1 },
                        { name: 'Web (Stun)', type: 'status', animation: 'stun', hitChance: 50, duration: 1, statusName: 'stunned', level: 3 },
                    ]},
                    { name: 'Fake Treasure', url: 'https://i.postimg.cc/V6MY36NM/SSP-N-Faketreasure.png', abilities: [
                        { name: 'Surprise Bite', type: 'attack', animation: 'slash', hitChance: 90, damageRange: [5, 15], level: 3 },
                    ]},
                    { name: 'Goblin Ambush', url: 'https://i.postimg.cc/VNJsW4QH/SSP-N-goblin-ambush.png', abilities: [
                        { name: 'Coordinated Volley (Splash)', type: 'splash', animation: 'slash', hitChance: 65, damageRange: [6, 12], level: 4 },
                    ]},
                    { name: 'Goblins', url: 'https://i.postimg.cc/yND6yn4M/SSP-N-Goblins.png', abilities: [
                        { name: 'Coordinated Attack', type: 'attack', animation: 'slash', hitChance: 80, damageRange: [6, 10], level: 2 },
                    ]},
                    { name: 'Wolf Group', url: 'https://i.postimg.cc/Njfj5BN9/SSP-N-Wolfgroup.png', abilities: [
                        { name: 'Mass Bite', type: 'splash', animation: 'slash', hitChance: 75, damageRange: [5, 9], level: 3 },
                    ]},
                    { name: 'Orc Boss', url: 'https://i.postimg.cc/X79nJTjK/SSP-N-Orc-Boss.png', abilities: [
                        { name: 'Heavy Axe', type: 'attack', animation: 'slash', hitChance: 70, damageRange: [18, 30], level: 7 },
                        { name: 'War Cry (Buff)', type: 'status', animation: 'arcane-buff', hitChance: 100, duration: 2, statusName: 'blessed', level: 8 },
                    ]},
                    { name: 'Shadow Boss', url: 'https://i.postimg.cc/QdPmyn7y/SSP-N-Shadowboss.png', abilities: [
                        { name: 'Shadow Blast', type: 'attack', animation: 'drain', hitChance: 80, damageRange: [25, 40], level: 9 },
                        { name: 'Shadow Drain (DoT)', type: 'dot', animation: 'drain', hitChance: 90, damageRange: [8, 12], duration: 4, level: 10, statusName: 'Shadow Drain' },
                    ]},
                    { name: 'Dragon', url: 'https://i.postimg.cc/zvzPrtjz/SSP-N-Dragon.png', abilities: [
                        { name: 'Fire Breath', type: 'splash', animation: 'fireball', hitChance: 85, damageRange: [30, 50], level: 10 },
                        { name: 'Tail Whip', type: 'attack', animation: 'slash', hitChance: 90, damageRange: [15, 25], level: 8 },
                        { name: 'Fear Presence', type: 'status', animation: 'frightened', hitChance: 80, duration: 3, statusName: 'frightened', level: 9 },
                    ]},
                ]
            },
            chatMessages: [],
            turnTracker: { order: [], currentIndex: -1 },
            journalEntries: [],
            battle: {
                isActive: false,
                combatants: [],
                turnIndex: 0,
                log: [],
                // UPDATED Timer State
                turnTimerDuration: 60, // Seconds
                turnTimerStartTime: null, // Firestore Timestamp when turn begins
                turnOrder: []
            },
            audioLink: null,
        };
        
        // --- CORE UTILITY FUNCTIONS (Moved to be defined early) ---
        
        function sendChatMessage(text, type = 'message') { 
            if (!text) return; 
            const senderName = type === 'system' ? 'System' : currentUsername; 
            const newMessage = { id: crypto.randomUUID(), sender: senderName, text, type, timestamp: Date.now() }; 
            const updatedMessages = [...(vttState.chatMessages || []), newMessage].slice(-100); 
            updateDoc(vttDocRef, { chatMessages: updatedMessages }); 
        }

        function getImageDimensions(url) { 
            return new Promise((resolve, reject) => { 
                const img = new Image(); 
                img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight }); 
                img.onerror = (err) => reject(err); 
                img.src = url; 
            }); 
        }

        async function updateActiveMapImage(url) { 
            const activeMap = getActiveMap(); 
            if (!activeMap) return; 
            try { 
                const { width, height } = await getImageDimensions(url); 
                const updatedMaps = vttState.maps.map(m => m.id === activeMap.id ? {...m, url, width, height} : m); 
                updateDoc(vttDocRef, { maps: updatedMaps }); 
            } catch (error) { 
                console.error("Failed to load map image:", error); 
                const updatedMaps = vttState.maps.map(m => m.id === activeMap.id ? {...m, url: 'https://placehold.co/1200x800/c00/fff?text=Error', width: 1200, height: 800} : m); 
                updateDoc(vttDocRef, { maps: updatedMaps }); 
            } 
        }

        function handleDeleteFromTracker(indexToDelete) { 
            const tracker = vttState.turnTracker; 
            const newOrder = tracker.order.filter((_, index) => index !== indexToDelete); 
            let newCurrentIndex = tracker.currentIndex; 
            if (indexToDelete < newCurrentIndex) newCurrentIndex--; 
            else if (indexToDelete === newCurrentIndex && newCurrentIndex >= newOrder.length) { 
                newCurrentIndex = newOrder.length > 0 ? 0 : -1; 
            } 
            if(newCurrentIndex < 0 && newOrder.length > 0) newCurrentIndex = 0; 
            updateDoc(vttDocRef, { turnTracker: { order: newOrder, currentIndex: newCurrentIndex } }); 
        }

        function handleDeleteToken(tokenId) { 
            const activeMap = getActiveMap(); 
            if (!activeMap) return; 
            activeMap.tokens = (activeMap.tokens || []).filter(t => t.id !== tokenId); 
            updateDoc(vttDocRef, { maps: vttState.maps }); 
        }

        function handleDeleteFogBlock(blockId) { 
            const activeMap = getActiveMap(); 
            if (!activeMap) return; 
            activeMap.fogBlocks = (activeMap.fogBlocks || []).filter(b => b.id !== blockId); 
            updateDoc(vttDocRef, { maps: vttState.maps }); 
        }

        function handleDeleteJournal(entryId) { 
            const updatedJournal = (vttState.journalEntries || []).filter(e => e.id !== entryId); 
            updateDoc(vttDocRef, { journalEntries: updatedJournal }); 
        }
        
        function clearAllData() {
            // We clone DEFAULT_STATE to ensure we don't accidentally modify the constant in memory
            const resetState = JSON.parse(JSON.stringify(DEFAULT_STATE));
            
            // Perform the reset
            setDoc(vttDocRef, resetState)
                .then(() => {
                    sendChatMessage("Session data successfully reset to default.", "system");
                })
                .catch(error => {
                    console.error("Error clearing data:", error);
                    sendChatMessage(`ERROR: Failed to clear session data. Details: ${error.message}`, "system");
                });
        }
        // --- END CORE UTILITY FUNCTIONS ---


        // --- Login and Initialization ---
        document.getElementById('join-session-btn').addEventListener('click', handleLogin);
        document.getElementById('username-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleLogin();
        });
        
        document.getElementById('start-session-btn').addEventListener('click', () => {
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('app').classList.remove('hidden');
        });

        async function handleLogin() {
            const usernameInput = document.getElementById('username-input');
            const username = usernameInput.value.trim();
            const loginError = document.getElementById('login-error');

            if (!username) {
                loginError.textContent = 'Username cannot be empty.';
                return;
            }
            loginError.textContent = '';
            
            isDM = username.toLowerCase().endsWith('dm');
            
            try {
                let userCredential;
                if (auth.currentUser) {
                    userCredential = { user: auth.currentUser };
                } else if (initialAuthToken) {
                    // FIX: Using the safely declared local variable initialAuthToken
                    userCredential = await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    // This is the fallback for running from a local file (no Canvas environment)
                    userCredential = await signInAnonymously(auth);
                }

                userId = userCredential.user.uid;
                currentUsername = username;
                usersCollectionRef = collection(db, `artifacts/${appId}/public/data/users`);
                const userDocRef = doc(usersCollectionRef, userId);

                await setDoc(userDocRef, {
                    username: currentUsername,
                    lastSeen: serverTimestamp()
                });

                document.getElementById('login-screen').classList.add('hidden');
                document.getElementById('title-screen').classList.remove('hidden');
                initializeAppCore();

            } catch (error) {
                console.error("Authentication/Login failed:", error);
                loginError.textContent = 'Could not connect to session.';
            }
        }

        // --- Helper function to get the currently active map object ---
        function getActiveMap() {
            if (!vttState.activeMapId || !vttState.maps) return null;
            // Ensure drawing object and fowEnabled exist for consistency
            let activeMap = vttState.maps.find(m => m.id === vttState.activeMapId);
            if (activeMap) {
                if (!activeMap.drawing) activeMap.drawing = DEFAULT_STATE.maps[0].drawing;
                if (typeof activeMap.fowEnabled === 'undefined') activeMap.fowEnabled = true;
                if (!activeMap.fogBlocks) activeMap.fogBlocks = []; // Ensure fogBlocks exists
            }
            return activeMap;
        }
        
        // Helper function to find a token on the active map
        function getActiveToken(tokenId) {
            const activeMap = getActiveMap();
            return activeMap ? (activeMap.tokens || []).find(t => t.id === tokenId) : null;
        }

        function playEffect(e) {
            if (!armedEffect) return;
            const activeMap = getActiveMap();
            if (!activeMap) return;

            const mapContainer = document.getElementById('map-container');
            const mapContent = document.getElementById('map-content');
            const containerRect = mapContainer.getBoundingClientRect();
            
            const mouseX = e.clientX - containerRect.left;
            const mouseY = e.clientY - containerRect.top;

            const { panX, panY, scale } = activeMap.transform;
            const mapX = (mouseX - panX) / scale;
            const mapY = (mouseY - panY) / scale;
            
            const effectEl = document.createElement('div');
            effectEl.className = `spell-effect effect-${armedEffect}`;
            effectEl.style.left = `${mapX}px`;
            effectEl.style.top = `${mapY}px`;
            
            mapContent.appendChild(effectEl);
            
            setTimeout(() => { effectEl.remove(); }, 1500); // Increased duration for new effects

            document.querySelectorAll('.effect-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('map-container').style.cursor = 'move';
            armedEffect = null;
        }

        function setupEffectControls() {
            const effectPanel = document.getElementById('spell-effects-panel');
            effectPanel.addEventListener('click', (e) => {
                if (e.target.matches('.effect-btn')) {
                    const effectType = e.target.dataset.effect;
                    if (armedEffect === effectType) {
                        armedEffect = null;
                        e.target.classList.remove('active');
                        document.getElementById('map-container').style.cursor = 'move';
                    } else {
                        armedEffect = effectType;
                        document.querySelectorAll('.effect-btn').forEach(btn => btn.classList.remove('active'));
                        e.target.classList.add('active');
                        document.getElementById('map-container').style.cursor = 'crosshair';
                    }
                }
            });
        }

        function setupTabs() {
            const controlsTabBtn = document.getElementById('controls-tab-btn');
            const journalTabBtn = document.getElementById('journal-tab-btn');
            const controlsContent = document.getElementById('controls-tab-content');
            const journalContent = document.getElementById('journal-tab-content');
            controlsTabBtn.addEventListener('click', () => {
                controlsContent.classList.remove('hidden');
                controlsContent.classList.add('flex');
                journalContent.classList.add('hidden');
                journalContent.classList.remove('flex');
                controlsTabBtn.classList.add('active');
                journalTabBtn.classList.remove('active');
            });
            journalTabBtn.addEventListener('click', () => {
                journalContent.classList.remove('hidden');
                journalContent.classList.add('flex');
                controlsContent.classList.add('hidden');
                controlsContent.classList.remove('flex');
                journalTabBtn.classList.add('active');
                controlsTabBtn.classList.remove('active');
            });
        }

        function setupStatBlockModal() {
            const modal = document.getElementById('stat-block-modal');
            document.getElementById('stat-block-close-btn').addEventListener('click', hideStatBlock);
            document.getElementById('stat-block-save-btn').addEventListener('click', saveStatBlock);
            modal.addEventListener('click', (e) => { if(e.target === modal) hideStatBlock(); });
            document.getElementById('add-ability-btn').addEventListener('click', addAbilityToStatBlock);
            document.getElementById('open-ability-library-btn').addEventListener('click', openAbilityLibrary);
            
            // Toggle visibility for attack vs status/DoT fields
            const abilityTypeSelect = document.getElementById('ability-type');
            const hitChanceInput = document.getElementById('ability-hitchance');
            const statusSelect = document.getElementById('ability-status-select');
            const damageMinMax = document.querySelectorAll('#ability-damage-min, #ability-damage-max');
            const durationInput = document.getElementById('ability-duration');

            const toggleAbilityFields = (type) => {
                const isDamageOrHeal = type === 'attack' || type === 'splash' || type === 'heal' || type === 'dot' || type === 'hot';
                const isAttackOrStatus = type === 'attack' || type === 'splash' || type === 'status' || type === 'dot' || type === 'hot';
                const isStatus = type === 'status';
                const isDuration = type === 'dot' || type === 'hot' || type === 'status';

                hitChanceInput.style.display = isAttackOrStatus ? 'block' : 'none';
                
                damageMinMax.forEach(input => input.style.display = isDamageOrHeal ? 'block' : 'none');
                
                statusSelect.style.display = isStatus ? 'block' : 'none';

                durationInput.style.display = isDuration ? 'block' : 'none';
                
                // Update placeholders
                durationInput.placeholder = 'Duration (Turns)';
                if (type === 'dot' || type === 'hot') {
                    hitChanceInput.placeholder = 'Hit % (Applies Effect)';
                    damageMinMax.forEach(input => input.placeholder = 'Min/Max Tick Dmg/Heal');
                } else if (type === 'attack' || type === 'splash') {
                    hitChanceInput.placeholder = 'Hit % (for attacks)';
                    damageMinMax.forEach(input => input.placeholder = 'Min/Max Dmg');
                } else if (type === 'status') {
                     hitChanceInput.placeholder = 'Hit % (Applies Status)';
                }
            };
            abilityTypeSelect.addEventListener('change', (e) => toggleAbilityFields(e.target.value));
            toggleAbilityFields(abilityTypeSelect.value); // Set initial state

            // Library Modal Setup
            document.getElementById('ability-library-close-btn').addEventListener('click', closeAbilityLibrary);
            document.getElementById('ability-library-level-filter').addEventListener('change', renderAbilityLibrary);
            document.getElementById('ability-library-search').addEventListener('input', renderAbilityLibrary);
            document.getElementById('ability-library-list').addEventListener('click', handleAbilitySelectFromLibrary);
        }

        function applyPermissions() {
            const dmControlsWrappers = document.querySelectorAll('.dm-controls-wrapper');
            
            dmControlsWrappers.forEach(wrapper => {
                if (isDM) {
                    wrapper.classList.remove('hidden');
                    wrapper.style.display = 'flex'; // Ensure flex layout is restored
                } else {
                    // Use CSS to hide elements not controlled by the user
                    wrapper.classList.add('hidden');
                    wrapper.style.display = 'none';
                }
            });

            // Player can only interact with Ruler and their own tokens.
            if (!isDM) {
                document.getElementById('status-effects-container').classList.add('opacity-50', 'pointer-events-none');
            }
        }

        function handleStatusEffectClick(e) { 
             if (e.target.matches('.status-effect-btn')) { 
                const activeMap = getActiveMap(); 
                if (!activeMap || !selectedElement || selectedElement.type !== 'token' || !isDM) return; 
                const tokenIndex = (activeMap.tokens || []).findIndex(t => t.id === selectedElement.id); 
                if (tokenIndex === -1) return; 
                const token = activeMap.tokens[tokenIndex]; 
                const effects = new Set(token.statusEffects || []); 
                const status = e.target.dataset.status; 
                if (effects.has(status)) effects.delete(status); 
                else effects.add(status); 
                token.statusEffects = Array.from(effects); 
                updateDoc(vttDocRef, { maps: vttState.maps }); 
            } 
        }

        function initializeAppCore() {
            document.getElementById('sessionIdDisplay').textContent = appId;
            document.getElementById('usernameDisplay').textContent = currentUsername;

            // Voice Clip button setup
            document.getElementById('voice-clip-btn').addEventListener('click', handleVoiceClipClick);
            document.getElementById('stop-record-btn').addEventListener('click', stopRecording);
            document.getElementById('cancel-record-btn').addEventListener('click', cancelRecording);

            // RENAMED AND NEW CANVAS INITIALIZATION
            overlayCanvas = document.getElementById('overlay-canvas');
            overlayCtx = overlayCanvas.getContext('2d');
            fowCanvas = document.getElementById('fow-canvas');
            fowCtx = fowCanvas.getContext('2d');

            setInterval(() => {
                if (userId) {
                    const userDocRef = doc(usersCollectionRef, userId);
                    updateDoc(userDocRef, { lastSeen: serverTimestamp() }).catch(console.error);
                }
            }, 15000); // Heartbeat every 15 seconds

            setupVTTListener();
            setupUsersListener();
            setupBattleSystem();
            
            const mapContainer = document.getElementById('map-container');
            mapContainer.addEventListener('mousedown', handleMapMouseDown);
            mapContainer.addEventListener('mousemove', handleMapMouseMove);
            window.addEventListener('mouseup', handleMapMouseUp); // Listen on window to catch mouseup outside map
            
            mapContainer.addEventListener('click', (e) => {
                if (armedEffect) { 
                    playEffect(e);
                    return; 
                } 
                if (activeTool === 'pan' && e.target.closest('.map-token, .fog-block') === null && !getTemplateAt(getMapCoords(e))) {
                    selectedElement = null;
                    document.querySelectorAll('.map-token, .fog-block').forEach(el => {
                        el.classList.remove('selected');
                        const handle = el.querySelector('.resize-handle');
                        if (handle) handle.remove();
                    });
                    redrawOverlayCanvas(); // Deselect templates too
                    renderTokenControls();
                    renderTemplateControls();
                }
            });

            document.getElementById('add-map-btn').addEventListener('click', handleAddMap);
            // NEW: Fog Block Listener
            document.getElementById('add-fog-btn').addEventListener('click', handleAddFogBlock); 

            setupMapControls();
            setupGridControls();
            setupDrawingControls(); 
            document.getElementById('status-effects-container').addEventListener('click', handleStatusEffectClick);
            setupStatBlockModal();
            setupTabs();
            setupEffectControls();
            setupToolControls();
            setupTokenBankControls();
            setupEmbeddedAudioControls(); 
            applyPermissions();
        }

        // --- Voice Recording Logic (NEW) ---

        async function handleVoiceClipClick() {
            if (!navigator.mediaDevices || !window.MediaRecorder) {
                showModal("Feature Unavailable", "Your browser does not support audio recording. Please use an updated browser.", () => {});
                return;
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];

                mediaRecorder.ondataavailable = event => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    // Clean up stream tracks
                    stream.getTracks().forEach(track => track.stop());

                    if (audioBlob.size > 0) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            sendChatMessage(e.target.result, 'voice');
                        };
                        reader.readAsDataURL(audioBlob);
                    }
                    
                    document.getElementById('voice-recording-modal').classList.add('hidden');
                    clearTimeout(recordingTimeout);
                };

                mediaRecorder.start();

                document.getElementById('voice-modal-title').textContent = 'Recording Voice Clip...';
                document.getElementById('voice-modal-message').textContent = 'Speak now (max 10 seconds).';
                document.getElementById('voice-recording-modal').classList.remove('hidden');

                // Set max recording time (10 seconds)
                recordingTimeout = setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                           mediaRecorder.stop();
                           showModal("Time's Up", "Recording stopped automatically (10 sec limit). Sending message.", () => {});
                    }
                }, 10000);

            } catch (err) {
                console.error("Microphone access failed:", err);
                showModal("Access Denied", "Could not access microphone. Please ensure permissions are granted.", () => {});
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }
        }

        function cancelRecording() {
            if (mediaRecorder) {
                if (mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
                // Stop microphone stream tracks immediately
                if (mediaRecorder.stream) {
                        mediaRecorder.stream.getTracks().forEach(track => track.stop());
                }
                
                document.getElementById('voice-recording-modal').classList.add('hidden');
                clearTimeout(recordingTimeout);
            }
        }

        // --- Listeners ---
        function setupUsersListener() {
            const q = query(usersCollectionRef);
            onSnapshot(q, (snapshot) => {
                const users = [];
                const threshold = Date.now() - 30000;
                snapshot.forEach((doc) => {
                    const user = doc.data();
                    if (user.lastSeen && user.lastSeen.toMillis() > threshold) {
                        users.push({ id: doc.id, username: user.username });
                    }
                });
                activeUserList = users;
                renderActiveUsers(users.map(u => u.username));
            });
        }

        function setupVTTListener() {
            onSnapshot(vttDocRef, (doc) => {
                if (doc.exists()) {
                    let data = doc.data();
                    // Migration for older states
                    if (!data.maps || !Array.isArray(data.maps)) {
                        console.log("Old VTT state detected, migrating...");
                        const newMapId = crypto.randomUUID();
                        const migratedMap = { id: newMapId, name: "Imported Map", url: data.mapUrl || DEFAULT_STATE.maps[0].url, width: data.mapWidth || 1200, height: data.mapHeight || 800, transform: data.mapTransform || { scale: 1, panX: 0, panY: 0 }, tokens: data.tokens || [], fogBlocks: data.fogBlocks || [], grid: data.grid || { enabled: false, size: 50, color: '#FFFFFF' }, spellTemplates: [], drawing: DEFAULT_STATE.maps[0].drawing, fowEnabled: DEFAULT_STATE.maps[0].fowEnabled };
                        const migratedState = { ...DEFAULT_STATE, maps: [migratedMap], activeMapId: newMapId, presetMaps: data.presetMaps || DEFAULT_STATE.presetMaps, chatMessages: data.chatMessages || [], turnTracker: data.turnTracker || DEFAULT_STATE.turnTracker, journalEntries: data.journalEntries || [] };
                        setDoc(vttDocRef, migratedState);
                        return;
                    }
                    vttState = { ...DEFAULT_STATE, ...data };
                    // Ensure drawing sub-state and fowEnabled exists on all maps (for backward compatibility)
                    vttState.maps = vttState.maps.map(m => {
                        if (!m.drawing) m.drawing = DEFAULT_STATE.maps[0].drawing;
                        if (typeof m.fowEnabled === 'undefined') m.fowEnabled = true;
                        return m;
                    });
                    // Ensure audioLink exists on state
                    if (!vttState.audioLink) vttState.audioLink = DEFAULT_STATE.audioLink;
                    // Ensure turn duration state exists (NEW)
                    if (typeof vttState.battle.turnTimerDuration === 'undefined') vttState.battle.turnTimerDuration = DEFAULT_STATE.battle.turnTimerDuration;

                    
                    if (!vttState.activeMapId || !vttState.maps.find(m => m.id === vttState.activeMapId)) {
                        vttState.activeMapId = vttState.maps.length > 0 ? vttState.maps[0].id : null;
                    }
                    render();
                } else {
                    setDoc(vttDocRef, DEFAULT_STATE).catch(console.error);
                }
            }, (error) => {
                console.error("Firestore listener error: ", error);
                document.getElementById('map-container').innerHTML = `<div class="text-red-400 p-8 text-center">Error connecting. Please refresh.</div>`;
            });
        }
        
        // --- Render Functions ---
        function renderActiveUsers(users) {
            const userListEl = document.getElementById('user-list');
            userListEl.innerHTML = '';
            if (users.length <= 1) {
                userListEl.innerHTML = '<li>Just you!</li>';
            } else {
                users.sort().forEach(username => {
                    const li = document.createElement('li');
                    li.textContent = username;
                    userListEl.appendChild(li);
                });
            }
        }
        
        function render() {
            const isBattleActive = vttState.battle && vttState.battle.isActive;
            document.getElementById('app').style.display = isBattleActive ? 'none' : 'grid';
            document.getElementById('battle-screen').style.display = isBattleActive ? 'flex' : 'none';

            // Sync shared audio link visibility
            syncEmbeddedAudio(vttState.audioLink);

            if (isBattleActive) {
                renderBattleScreen();
            } else {
                // Hide battle end message when not in battle
                document.getElementById('battle-end-message').classList.add('hidden');
                renderTokenBank();
                renderMapTabs();
                renderMap();
                renderGridControls();
                renderDrawingControls(); 
                renderPresetMaps();
                renderTokensAndFog();
                renderChat();
                renderTurnTracker();
                renderJournal();
                renderTokenControls();
                renderTemplateControls();
                redrawOverlayCanvas(); // Master redraw for drawing/templates/ruler/FoW
            }
        }
        
        function handleRenameMap(mapId) {
            const map = vttState.maps.find(m => m.id === mapId);
            if (!map || !isDM) return;
            
            const newName = prompt(`Rename map "${map.name}" to:`, map.name);
            if (newName && newName.trim() !== map.name) {
                const updatedMaps = vttState.maps.map(m => m.id === mapId ? { ...m, name: newName.trim() } : m);
                updateDoc(vttDocRef, { maps: updatedMaps });
            }
        }

        function renderMapTabs() {
            const tabsContainer = document.getElementById('map-tabs-container');
            tabsContainer.querySelectorAll('.map-tab').forEach(tab => tab.remove());
            (vttState.maps || []).forEach(map => {
                const tab = document.createElement('button');
                tab.className = 'map-tab';
                tab.textContent = map.name;
                tab.dataset.mapId = map.id; // Store map ID on the element

                if (map.id === vttState.activeMapId) tab.classList.add('active');
                
                // CHECK: Only DM can switch map tabs
                if (isDM) {
                    tab.addEventListener('click', () => { 
                        if (vttState.activeMapId !== map.id) {
                            updateDoc(vttDocRef, { activeMapId: map.id });
                        }
                    });
                } else {
                    tab.style.cursor = 'default';
                    // Remove clickability for non-DMs
                    tab.classList.add('opacity-70');
                    tab.style.pointerEvents = 'none'; 
                }
                
                // Right-click to rename map (DM ONLY)
                tab.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    if (isDM) handleRenameMap(map.id);
                });

                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'map-tab-delete';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.title = 'Delete Map';
                
                // Only prevent deletion if it is the LAST remaining map
                if ((vttState.maps || []).length <= 1) {
                    deleteBtn.style.display = 'none';
                } else if (isDM) {
                     deleteBtn.addEventListener('click', (e) => { e.stopPropagation(); handleDeleteMap(map.id); });
                }
                
                tab.appendChild(deleteBtn);
                tabsContainer.insertBefore(tab, document.getElementById('add-map-btn'));
            });
        }

        function renderMap() {
            const mapContent = document.getElementById('map-content');
            const activeMap = getActiveMap();
            if (!activeMap) {
                mapContent.style.backgroundImage = `url('https://placehold.co/1200x800/3a241d/e6d5b8?text=No+Map+Selected')`;
                mapContent.style.width = `100%`;
                mapContent.style.height = `100%`;
                mapContent.style.transform = '';
                drawGrid();
                return;
            }
            const { url, width, height, transform } = activeMap;
            mapContent.style.backgroundImage = `url('${url}')`;
            mapContent.style.width = `${width}px`;
            mapContent.style.height = `${height}px`;
            
            // CANVAS SIZE UPDATES
            overlayCanvas.width = width; 
            overlayCanvas.height = height;
            fowCanvas.width = width; 
            fowCanvas.height = height; 

            mapContent.style.transform = `translate(${transform.panX}px, ${transform.panY}px) scale(${transform.scale})`;
            drawGrid();
            // redrawOverlayCanvas(); // Called by render()
            
            // NEW: Update drawing controls UI based on active map
            const drawingControls = document.getElementById('dm-drawing-controls');
            if (drawingControls) {
                drawingControls.style.display = isDM ? 'flex' : 'none';
            }
            if (isDM && activeMap.drawing) {
                document.getElementById('drawing-color-input').value = activeMap.drawing.color;
                document.getElementById('drawing-thickness-input').value = activeMap.drawing.thickness;
                document.getElementById('drawing-thickness-display').textContent = activeMap.drawing.thickness;
            }
        }

        function drawGrid() {
            const canvas = document.getElementById('grid-canvas');
            const ctx = canvas.getContext('2d');
            const activeMap = getActiveMap();
            if (!activeMap) { canvas.width = 0; canvas.height = 0; ctx.clearRect(0,0,0,0); return; }
            const { enabled, size, color } = activeMap.grid;
            canvas.width = activeMap.width;
            canvas.height = activeMap.height;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!enabled || size <= 0) return;
            ctx.strokeStyle = color + '80';
            ctx.lineWidth = 1 / (activeMap.transform.scale || 1);
            for (let x = 0; x < canvas.width; x += size) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let y = 0; y < canvas.height; y += size) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
        }
        
        function renderPresetMaps() {
            const selectEl = document.getElementById('preset-map-select');
            const activeMap = getActiveMap();
            selectEl.innerHTML = '<option value="">-- Select a Preset Map --</option>';
            if (!activeMap) return;
            (vttState.presetMaps || []).forEach(map => {
                const option = document.createElement('option');
                option.value = map.url;
                option.textContent = map.name;
                if (map.url === activeMap.url) option.selected = true;
                selectEl.appendChild(option);
            });
        }

        function renderTokenBank() {
            const tabsContainer = document.getElementById('token-bank-tabs');
            const contentContainer = document.getElementById('token-bank-content');
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = '';

            const categories = Object.keys(vttState.presetTokens || {});
            categories.forEach(category => {
                const tab = document.createElement('button');
                tab.className = 'token-bank-tab';
                tab.textContent = category;
                tab.dataset.category = category;
                if (category === activeTokenCategory) {
                    tab.classList.add('active');
                }
                tabsContainer.appendChild(tab);
            });

            const tokens = vttState.presetTokens[activeTokenCategory] || [];
            tokens.forEach(token => {
                const tokenEl = document.createElement('div');
                tokenEl.className = 'w-12 h-12 bg-cover bg-center rounded-md cursor-pointer border-2 border-transparent hover:border-[#ffd700]';
                tokenEl.style.backgroundImage = `url('${token.url}')`;
                tokenEl.title = `Add ${token.name}`;
                tokenEl.dataset.name = token.name;
                tokenEl.dataset.url = token.url;
                contentContainer.appendChild(tokenEl);
            });
        }

        function renderTokensAndFog() {
            const mapContent = document.getElementById('map-content');
            mapContent.querySelectorAll('.map-token, .fog-block').forEach(el => el.remove());
            const activeMap = getActiveMap();
            if (!activeMap) return;

            (activeMap.tokens || []).forEach(token => {
                const tokenEl = document.createElement('div');
                tokenEl.className = 'map-token';
                tokenEl.id = `token-${token.id}`;
                tokenEl.style.left = `${token.x}px`;
                tokenEl.style.top = `${token.y}px`;
                tokenEl.style.width = `${token.width}px`;
                tokenEl.style.height = `${token.height}px`;
                tokenEl.style.backgroundImage = token.imageUrl ? `url('${token.imageUrl}')` : 'none';
                tokenEl.style.backgroundColor = token.imageUrl ? 'transparent' : token.color;
                tokenEl.textContent = token.imageUrl ? '' : token.name;
                tokenEl.title = `${token.name}\nHP: ${token.hp || 0}/${token.maxHp || 0}\nAC: ${token.ac || 0}`;

                // --- MODIFIED CLICK HANDLER ---
                tokenEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (isDM || token.ownedBy === userId || token.ownedBy === DM_PLAYER_GMPC_ID) {
                        if (armedEffect) { playEffect(e); return; }
                        // Left-click only handles selection and movement initiation
                        if (selectedElement && selectedElement.id === token.id) return;
                        selectedElement = { type: 'token', id: token.id };
                        document.querySelectorAll('.map-token, .fog-block').forEach(el => { el.classList.remove('selected'); const handle = el.querySelector('.resize-handle'); if (handle) handle.remove(); });
                        tokenEl.classList.add('selected');
                        addResizeHandles(tokenEl, token, 'token');
                        renderTokenControls();
                        renderTemplateControls();
                        redrawOverlayCanvas(); // Deselect other elements/handles
                    }
                });

                // --- ADDED RIGHT-CLICK HANDLER ---
                tokenEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (isDM || token.ownedBy === userId || token.ownedBy === DM_PLAYER_GMPC_ID) {
                        // Right-click opens the stat block modal
                        selectedElement = { type: 'token', id: token.id };
                        document.querySelectorAll('.map-token, .fog-block').forEach(el => { el.classList.remove('selected'); const handle = el.querySelector('.resize-handle'); if (handle) handle.remove(); });
                        tokenEl.classList.add('selected');
                        addResizeHandles(tokenEl, token, 'token');
                        renderTokenControls();
                        renderTemplateControls();
                        redrawOverlayCanvas(); // Deselect other elements/handles
                        showStatBlock(token);
                    }
                });
                // --- END MODIFIED CLICK HANDLER ---

                if (selectedElement && selectedElement.type === 'token' && selectedElement.id === token.id) { tokenEl.classList.add('selected'); addResizeHandles(tokenEl, token, 'token'); }
                const statusContainer = document.createElement('div'); statusContainer.className = 'absolute top-0 left-0 w-full h-full'; 
                (token.statusEffects || []).forEach((status, index) => { const statusEl = document.createElement('div'); statusEl.className = 'status-effect-icon'; statusEl.textContent = STATUS_ICONS[status] || '?'; const angle = (index / (token.statusEffects.length || 1)) * 2 * Math.PI; statusEl.style.left = `calc(${50 + 45 * Math.cos(angle)}% - 8px)`; statusEl.style.top = `calc(${50 + 45 * Math.sin(angle)}% - 8px)`; statusContainer.appendChild(statusEl); });
                tokenEl.appendChild(statusContainer);
                if (isDM) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.className = 'absolute -top-1 -right-1 text-white bg-black bg-opacity-50 rounded-full h-4 w-4 flex items-center justify-center text-xs z-20';
                    deleteBtn.onclick = (e) => { e.stopPropagation(); handleDeleteToken(token.id); };
                    tokenEl.appendChild(deleteBtn);
                }
                if (token.maxHp > 0) { const healthBarContainer = document.createElement('div'); healthBarContainer.style.cssText = 'position: absolute; bottom: -10px; left: 0; width: 100%; height: 6px; background-color: #b91c1c; border-radius: 3px; overflow: hidden; border: 1px solid #450a0a;'; const healthBar = document.createElement('div'); const healthPercentage = Math.max(0, Math.min(100, (token.hp / token.maxHp) * 100)); healthBar.style.cssText = `width: ${healthPercentage}%; height: 100%; background-color: #16a34a; transition: width 0.3s ease;`; healthBarContainer.appendChild(healthBar); tokenEl.appendChild(healthBarContainer); }
                mapContent.appendChild(tokenEl);
                makeDraggable(tokenEl, token.id, 'token');
            });

            (activeMap.fogBlocks || []).forEach(block => {
                const fogEl = document.createElement('div');
                fogEl.className = 'fog-block';
                fogEl.id = `fog-${block.id}`;
                fogEl.style.left = `${block.x}px`;
                fogEl.style.top = `${block.y}px`;
                fogEl.style.width = `${block.width}px`;
                fogEl.style.height = `${block.height}px`;
                fogEl.addEventListener('click', (e) => { e.stopPropagation(); if (!isDM) return; if (armedEffect) { playEffect(e); return; } if (selectedElement && selectedElement.id === block.id) return; selectedElement = { type: 'fog', id: block.id }; document.querySelectorAll('.map-token, .fog-block').forEach(el => { el.classList.remove('selected'); const handle = el.querySelector('.resize-handle'); if (handle) handle.remove(); }); fogEl.classList.add('selected'); addResizeHandles(fogEl, block, 'fog'); renderTokenControls(); redrawOverlayCanvas(); });
                fogEl.addEventListener('contextmenu', (e) => { e.preventDefault(); if (isDM) handleDeleteFogBlock(block.id); });
                if (selectedElement && selectedElement.type === 'fog' && selectedElement.id === block.id) { fogEl.classList.add('selected'); addResizeHandles(fogEl, block, 'fog'); }
                mapContent.appendChild(fogEl);
                makeDraggable(fogEl, block.id, 'fog');
            });
        }
        
        function renderChat() {
            const chatMessagesContainer = document.getElementById('chat-messages');
            const shouldScroll = chatMessagesContainer.scrollTop + chatMessagesContainer.clientHeight >= chatMessagesContainer.scrollHeight - 20;
            chatMessagesContainer.innerHTML = '';
            (vttState.chatMessages || []).forEach(message => {
                const msgEl = document.createElement('div');
                msgEl.className = 'text-sm break-words';
                
                let messageContent;
                if (message.type === 'roll') {
                    messageContent = `<span class="italic text-yellow-300">${message.sender} ${message.text}</span>`;
                } else if (message.type === 'system') {
                    messageContent = `<span class="italic text-gray-400">${message.sender}: ${message.text}</span>`;
                } else if (message.type === 'voice') {
                    // NEW: Render Voice Clip Player
                    messageContent = `<strong class="text-[#c0a080]">${message.sender} (Voice Clip):</strong> 
                        <audio controls class="mt-1 w-full" src="${message.text}"></audio>`;
                } else {
                    messageContent = `<strong class="text-[#c0a080]">${message.sender}:</strong> <span class="text-gray-200">${message.text}</span>`;
                }
                
                msgEl.innerHTML = messageContent;
                chatMessagesContainer.appendChild(msgEl);
            });
            if (shouldScroll) {
                chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            }
        }

        function renderTurnTracker() {
            const trackerList = document.getElementById('turn-tracker-list');
            trackerList.innerHTML = '';
            const { order = [], currentIndex = -1 } = vttState.turnTracker || {};
            if (order.length === 0) {
                trackerList.innerHTML = '<p class="text-xs text-gray-400 text-center">Empty</p>';
                return;
            }
            order.forEach((name, index) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'flex justify-between items-center p-1 rounded text-sm transition-colors duration-200';
                if (index === currentIndex) {
                    itemEl.classList.add('bg-[#b8860b]', 'text-white');
                } else {
                    itemEl.classList.add('hover:bg-[#5a3d2b]');
                }
                const nameSpan = document.createElement('span');
                nameSpan.textContent = name;
                itemEl.appendChild(nameSpan);

                if (isDM) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.className = 'text-red-400 hover:text-red-200 font-bold px-1';
                    deleteBtn.title = 'Remove from tracker';
                    deleteBtn.onclick = () => handleDeleteFromTracker(index);
                    itemEl.appendChild(deleteBtn);
                }
                trackerList.appendChild(itemEl);
            });
        }
        
        function renderJournal() {
            const journalList = document.getElementById('journal-list');
            journalList.innerHTML = '';
            const entries = vttState.journalEntries || [];
            if (entries.length === 0) {
                journalList.innerHTML = '<p class="text-xs text-gray-400 text-center">No entries yet.</p>';
                return;
            }
            [...entries].reverse().forEach(entry => {
                const entryEl = document.createElement('div');
                entryEl.className = 'gruvhub-border p-2 rounded bg-[#3a241d] text-xs';
                
                const header = document.createElement('div');
                header.className = 'flex justify-between items-center mb-1';
                
                const title = document.createElement('h4');
                title.className = 'font-bold text-base text-gray-200';
                title.textContent = entry.title;
                header.appendChild(title);

                if (isDM) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '&times;';
                    deleteBtn.className = 'text-red-400 hover:text-red-200 font-bold text-lg';
                    deleteBtn.onclick = () => handleDeleteJournal(entry.id);
                    header.appendChild(deleteBtn);
                }
                
                entryEl.appendChild(header);

                const contentEl = document.createElement('div');
                contentEl.className = 'text-gray-300 whitespace-pre-wrap break-words';
                if (entry.content.match(/\.(jpeg|jpg|gif|png)$/i)) {
                    contentEl.innerHTML = `<img src="${entry.content}" alt="${entry.title}" class="max-w-full rounded mt-1">`;
                } else {
                    contentEl.textContent = entry.content;
                }
                entryEl.appendChild(contentEl);
                journalList.appendChild(entryEl);
            });
        }

        function renderTokenControls() {
            const panel = document.getElementById('token-controls-panel');
            const container = document.getElementById('status-effects-container');
            const title = panel.querySelector('h3');
            const activeMap = getActiveMap();
            const token = activeMap && selectedElement && selectedElement.type === 'token' ? (activeMap.tokens || []).find(t => t.id === selectedElement.id) : null;
            
            const activeTokenFileControls = document.getElementById('active-token-file-controls');

            if (token && isDM) {
                title.textContent = `Status: ${token.name}`;
                container.classList.remove('opacity-50', 'pointer-events-none');
                document.querySelectorAll('.status-effect-btn').forEach(btn => { btn.disabled = false; btn.classList.toggle('active', (token.statusEffects || []).includes(btn.dataset.status)); });
                activeTokenFileControls.classList.remove('hidden');
                activeTokenFileControls.classList.add('flex');
            } else {
                title.textContent = 'Status (No Token)';
                container.classList.add('opacity-50', 'pointer-events-none');
                document.querySelectorAll('.status-effect-btn').forEach(btn => { btn.disabled = true; btn.classList.remove('active'); });
                activeTokenFileControls.classList.add('hidden');
                activeTokenFileControls.classList.remove('flex');
            }
        }
        
        // --- Modal & Stat Block Logic ---
        function showModal(title, text, onConfirm) {
            const modal = document.getElementById('confirmation-modal');
            modal.querySelector('#modal-title').textContent = title;
            modal.querySelector('#modal-text').textContent = text;

            const confirmBtn = modal.querySelector('#modal-confirm-btn');
            const cancelBtn = modal.querySelector('#modal-cancel-btn');

            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            const newCancelBtn = cancelBtn.cloneNode(true);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            const hideModal = () => modal.classList.add('hidden');

            newConfirmBtn.addEventListener('click', () => {
                onConfirm();
                hideModal();
            }, { once: true });

            newCancelBtn.addEventListener('click', hideModal, { once: true });

            modal.classList.remove('hidden');
        }
        function showStatBlock(token) {
            const modal = document.getElementById('stat-block-modal');
            modal.dataset.tokenId = token.id;
            
            // New logic for name input
            const nameInput = document.getElementById('stat-block-name-input');
            nameInput.value = token.name;
            nameInput.disabled = !isDM; // Only DM can edit name

            ['hp', 'max-hp', 'ac', 'notes'].forEach(id => {
                const el = document.getElementById(`stat-block-${id}`);
                if(el) {
                    const key = id.replace('-','');
                    el.value = token[key] || (key === 'notes' ? '' : 0);
                    el.disabled = !isDM;
                }
            });
            
            // NEW: Vision Range
            const visionInput = document.getElementById('stat-block-vision-range');
            if (visionInput) {
                visionInput.value = token.visionRange || 0;
                visionInput.disabled = !isDM;
            }

            const ownerWrapper = document.getElementById('stat-block-owner-wrapper');
            const ownerSelect = document.getElementById('stat-block-owner');
            if (isDM) {
                ownerWrapper.classList.remove('hidden');
                ownerSelect.innerHTML = ''; // Clear previous options

                // 1. DM/Enemy Option (Default)
                const dmOption = document.createElement('option');
                dmOption.value = 'dm';
                dmOption.textContent = 'DM (Enemy/Unassigned)';
                if (token.ownedBy === 'dm') dmOption.selected = true;
                ownerSelect.appendChild(dmOption);

                // 2. DM Virtual Player Option (GMPC)
                const gmpcOption = document.createElement('option');
                gmpcOption.value = DM_PLAYER_GMPC_ID;
                gmpcOption.textContent = 'DM Player (GMPC)';
                if (token.ownedBy === DM_PLAYER_GMPC_ID) gmpcOption.selected = true;
                ownerSelect.appendChild(gmpcOption);

                // 3. Active Player Options
                // FIX: Ensure activeUserList is treated as an array for safe iteration
                (activeUserList || []).forEach(user => {
                    if (!user.username.toLowerCase().endsWith('dm')) {
                        const option = document.createElement('option');
                        option.value = user.id;
                        option.textContent = user.username;
                        if (token.ownedBy === user.id) option.selected = true;
                        ownerSelect.appendChild(option);
                    }
                });
            } else {
                ownerWrapper.classList.add('hidden');
            }
            
            document.getElementById('stat-block-abilities-wrapper').style.display = isDM ? 'block' : 'none';
            renderAbilitiesInStatBlock(token.abilities || []);

            document.getElementById('stat-block-save-btn').classList.toggle('hidden', !isDM);
            modal.classList.remove('hidden');
        }

        function hideStatBlock() { document.getElementById('stat-block-modal').classList.add('hidden'); }
        
        function saveStatBlock() {
            const activeMapId = getActiveMap()?.id;
            const tokenId = document.getElementById('stat-block-modal').dataset.tokenId;
            if (!isDM || !activeMapId || !tokenId) return;
            const updatedMaps = JSON.parse(JSON.stringify(vttState.maps));
            const mapToUpdate = updatedMaps.find(m => m.id === activeMapId);
            if (!mapToUpdate) return;
            const tokenToUpdate = (mapToUpdate.tokens || []).find(t => t.id === tokenId);
            if (!tokenToUpdate) return;
            
            // Apply new name
            tokenToUpdate.name = document.getElementById('stat-block-name-input').value.trim();

            tokenToUpdate.hp = parseInt(document.getElementById('stat-block-hp').value, 10) || 0;
            tokenToUpdate.maxHp = parseInt(document.getElementById('stat-block-max-hp').value, 10) || 0;
            tokenToUpdate.ac = parseInt(document.getElementById('stat-block-ac').value, 10) || 0;
            tokenToUpdate.notes = document.getElementById('stat-block-notes').value;
            tokenToUpdate.ownedBy = document.getElementById('stat-block-owner').value;
            tokenToUpdate.abilities = tokenToUpdate.abilities || []; // Ensure abilities are preserved if not re-saved
            // NEW: Save Vision Range
            tokenToUpdate.visionRange = parseInt(document.getElementById('stat-block-vision-range').value, 10) || 0;
            
            updateDoc(vttDocRef, { maps: updatedMaps });
            hideStatBlock();
        }

        // --- Map Controls & Tools ---
        function handleAddMap() { 
            const name = `Map ${(vttState.maps || []).length + 1}`; 
            const newMapId = crypto.randomUUID(); 
            const newMap = { 
                id: newMapId, 
                name: name, 
                url: 'https://placehold.co/1200x800/5a3d2b/e6d5b8?text=New+Map', 
                width: 1200, 
                height: 800, 
                transform: { scale: 1, panX: 0, panY: 0 }, 
                tokens: [], 
                fogBlocks: [], 
                grid: { enabled: false, size: 50, color: '#FFFFFF' }, 
                spellTemplates: [],
                drawing: DEFAULT_STATE.maps[0].drawing, // Add drawing state
                fowEnabled: DEFAULT_STATE.maps[0].fowEnabled,
            }; 
            const updatedMaps = [...(vttState.maps || []), newMap]; 
            updateDoc(vttDocRef, { maps: updatedMaps, activeMapId: newMapId }); 
        }

        function handleDeleteMap(mapId) { 
            if ((vttState.maps || []).length <= 1) { 
                showModal("Cannot Delete", "You must keep at least one map.", () => {});
                return;
            } 
            showModal("Delete Map?", "This will permanently delete this map and all its tokens. This cannot be undone.", () => { 
                const updatedMaps = vttState.maps.filter(m => m.id !== mapId); 
                let newActiveId = vttState.activeMapId; 
                if (newActiveId === mapId) { 
                    newActiveId = updatedMaps[0]?.id || null; 
                } 
                updateDoc(vttDocRef, { maps: updatedMaps, activeMapId: newActiveId }); 
            }); 
        }
        
        function setupMapControls() { 
            const mapContainer = document.getElementById('map-container'); 
            
            // Map Zooming (DM ONLY)
            mapContainer.addEventListener('wheel', (e) => { 
                e.preventDefault(); 
                if (!isDM) return; // <-- DM Restriction
                
                const activeMap = getActiveMap(); 
                if (!activeMap) return; 
                const { scale, panX, panY } = activeMap.transform; 
                const rect = mapContainer.getBoundingClientRect(); 
                const mouseX = e.clientX - rect.left; 
                const mouseY = e.clientY - rect.top; 
                const mapMouseX = (mouseX - panX) / scale; 
                const mapMouseY = (mouseY - panY) / scale; 
                const newScale = Math.max(0.1, Math.min(5, scale * (e.deltaY > 0 ? 0.9 : 1.1))); 
                activeMap.transform.panX = mouseX - mapMouseX * newScale; 
                activeMap.transform.panY = mouseY - mapMouseY * newScale; 
                activeMap.transform.scale = newScale; 
                updateDoc(vttDocRef, { maps: vttState.maps }); 
            }); 
            
            document.getElementById('reset-view-btn').addEventListener('click', () => { 
                const activeMap = getActiveMap(); 
                if (!activeMap) return; 
                activeMap.transform = { scale: 1, panX: 0, panY: 0 }; 
                updateDoc(vttDocRef, { maps: vttState.maps }); 
            }); 
            
            // FIX: Map Preset Listener Setup
            document.getElementById('preset-map-select').addEventListener('change', (e) => {
                const url = e.target.value;
                if (url) updateActiveMapImage(url);
            });
            
            // FIX: Set Active Map from URL Listener Setup
            document.getElementById('change-map-btn').addEventListener('click', () => { 
                const url = document.getElementById('map-url-input').value.trim(); 
                if (url) updateActiveMapImage(url); 
            });

            // NEW: Set Turn Duration Listener
            document.getElementById('set-turn-duration-btn').addEventListener('click', () => {
                const duration = parseInt(document.getElementById('turn-duration-input').value, 10);
                if (isDM && !isNaN(duration) && duration >= 10) {
                     updateDoc(vttDocRef, { 'battle.turnTimerDuration': duration });
                     sendChatMessage(`Turn duration set to ${duration} seconds.`, 'system');
                } else {
                    sendChatMessage("Invalid turn duration. Must be a number >= 10.", 'system');
                }
            });
        }

        function handleAddFogBlock() {
            if (!isDM) return;
            const activeMap = getActiveMap();
            if (!activeMap) {
                sendChatMessage("Cannot add fog: No active map.", "system");
                return;
            }

            const newBlock = {
                id: crypto.randomUUID(),
                x: activeMap.width / 2 - 100, // Center the block
                y: activeMap.height / 2 - 100,
                width: 200,
                height: 200,
            };

            // Add new block to the beginning of the array so it's easily selectable/manipulatable
            activeMap.fogBlocks.unshift(newBlock); 
            
            // Set it as selected to immediately show resize handles
            selectedElement = { type: 'fog', id: newBlock.id };

            updateDoc(vttDocRef, { maps: vttState.maps })
                .then(() => sendChatMessage("Added new fog block.", "system"))
                .catch(err => {
                    console.error("Error adding fog block:", err);
                    sendChatMessage("ERROR: Failed to add fog block.", "system");
                });
        }


        function setupGridControls() { 
            const updateMapConfig = (prop, value) => { 
                const activeMap = getActiveMap(); 
                if (!activeMap) return; 
                activeMap[prop] = value; 
                updateDoc(vttDocRef, { maps: vttState.maps }); 
            }; 
            document.getElementById('grid-toggle').addEventListener('change', (e) => updateMapConfig('grid', {...getActiveMap().grid, enabled: e.target.checked})); 
            document.getElementById('grid-size-input').addEventListener('input', (e) => { document.getElementById('grid-size-display').textContent = e.target.value; }); 
            document.getElementById('grid-size-input').addEventListener('change', (e) => updateMapConfig('grid', {...getActiveMap().grid, size: parseInt(e.target.value, 10)})); 
            document.getElementById('grid-color-input').addEventListener('input', (e) => updateMapConfig('grid', {...getActiveMap().grid, color: e.target.value})); 
            
            // NEW: FOW Toggle setup
            document.getElementById('fow-toggle').addEventListener('change', (e) => updateMapConfig('fowEnabled', e.target.checked));
        }
        
        function renderGridControls() { 
            const activeMap = getActiveMap(); 
            const enabled = activeMap ? activeMap.grid.enabled : false; 
            const size = activeMap ? activeMap.grid.size : 50; 
            const color = activeMap ? activeMap.grid.color : '#FFFFFF'; 
            document.getElementById('grid-toggle').checked = enabled; 
            document.getElementById('grid-size-input').value = size; 
            document.getElementById('grid-size-display').textContent = size; 
            document.getElementById('grid-color-input').value = color; 
            
            // NEW: Render FOW Toggle state
            document.getElementById('fow-toggle').checked = activeMap ? activeMap.fowEnabled : true;

            // NEW: Render Turn Duration in Controls
            document.getElementById('turn-duration-input').value = vttState.battle?.turnTimerDuration || DEFAULT_STATE.battle.turnTimerDuration;
        }
        
        // --- Draggable & Resizable Logic ---
        function makeDraggable(element, id, type) { 
            const activeMap = getActiveMap();
            const dataArray = type === 'token' ? activeMap.tokens : activeMap.fogBlocks;
            const itemIndex = dataArray.findIndex(i => i.id === id);
            const item = dataArray[itemIndex];

            let initialPos = { top: 0, left: 0 }; 
            
            element.onmousedown = (e) => { 
                if (activeTool !== 'pan') return;
                // Allow DM or the token owner (including GMPC owner) to move the token
                if (!isDM && (!item || type !== 'token' || (item.ownedBy !== userId && item.ownedBy !== DM_PLAYER_GMPC_ID))) return;
                
                if (e.button !== 0) return; 
                e.preventDefault(); 
                e.stopPropagation(); 
                
                // --- OPTIMIZED DRAG LOGIC ---
                const startX = e.clientX;
                const startY = e.clientY;
                const startItemX = item.x;
                const startItemY = item.y;
                
                window.onmousemove = (dragEvent) => { 
                    dragEvent.preventDefault(); 
                    const currentMap = getActiveMap(); 
                    if (!currentMap) return; 
                    const { scale } = currentMap.transform;
                    
                    const deltaX = dragEvent.clientX - startX;
                    const deltaY = dragEvent.clientY - startY;

                    // Calculate new position based on drag movement and map scale
                    const newX = startItemX + (deltaX / scale);
                    const newY = startItemY + (deltaY / scale);

                    // Update local state and DOM immediately for smooth visual feedback
                    item.x = newX;
                    item.y = newY;
                    element.style.left = newX + "px";
                    element.style.top = newY + "px";
                    
                    // Critical: Redraw FoW immediately after token moves locally
                    if (type === 'token' || type === 'fog') { // Fog blocks also need real-time redraw of fog overlay
                         redrawOverlayCanvas(); 
                    }
                }; 
                
                window.onmouseup = () => { 
                    window.onmouseup = null; 
                    window.onmousemove = null; 
                    
                    // Final update of the map state to Firestore (only sends once)
                    updateDoc(vttDocRef, { maps: vttState.maps });
                }; 
                // --- END OPTIMIZED DRAG LOGIC ---
            }; 
        }

        function addResizeHandles(element, data, type) {
            if (!isDM && (type !== 'token' || (data.ownedBy !== userId && data.ownedBy !== DM_PLAYER_GMPC_ID))) return; // Allow GMPC owner to resize
            const handle = document.createElement('div'); handle.className = 'resize-handle br'; element.appendChild(handle); handle.addEventListener('mousedown', (e) => initResize(e, element, data, type)); 
        }
        function initResize(e, element, data, type) { e.preventDefault(); e.stopPropagation(); const startX = e.clientX; const startY = e.clientY; const startWidth = parseInt(document.defaultView.getComputedStyle(element).width, 10); const startHeight = parseInt(document.defaultView.getComputedStyle(element).height, 10); const doResize = (moveEvent) => { const activeMap = getActiveMap(); if (!activeMap) return; const { scale } = activeMap.transform; const deltaX = moveEvent.clientX - startX; const deltaY = moveEvent.clientY - startY; let newWidth = startWidth + deltaX / scale; let newHeight = startHeight + deltaY / scale; if (type === 'token') { const aspectRatio = startWidth / startHeight; newHeight = newWidth / aspectRatio; } element.style.width = Math.max(20, newWidth) + 'px'; element.style.height = Math.max(20, newHeight) + 'px'; 
        if (type === 'token' || type === 'fog') { redrawOverlayCanvas(); } // Live redraw during resize
        }; const stopResize = () => { document.removeEventListener('mousemove', doResize); document.removeEventListener('mouseup', stopResize); const activeMap = getActiveMap(); if (!activeMap) return; const dataArray = type === 'token' ? activeMap.tokens : activeMap.fogBlocks; const itemIndex = dataArray.findIndex(item => item.id === data.id); if (itemIndex > -1) { dataArray[itemIndex].width = parseInt(element.style.width, 10); dataArray[itemIndex].height = parseInt(element.style.height, 10); updateDoc(vttDocRef, { maps: vttState.maps }); } }; document.addEventListener('mousemove', doResize); document.addEventListener('mouseup', stopResize, { once: true }); }
        
        // --- Measurement and Template Tools ---
        function getMapCoords(e) {
            const activeMap = getActiveMap();
            if (!activeMap) return {x: 0, y: 0};
            const mapContainer = document.getElementById('map-container');
            const rect = mapContainer.getBoundingClientRect();
            const { panX, panY, scale } = activeMap.transform;
            const x = (e.clientX - rect.left - panX) / scale;
            const y = (e.clientY - rect.top - panY) / scale;
            return { x, y };
        }

        function setupTokenBankControls() {
            document.getElementById('token-bank-content').addEventListener('click', (e) => {
                if (e.target.dataset.url) {
                    const { name, url } = e.target.dataset;
                    addTokenFromPreset(name, url);
                }
            });
            document.getElementById('token-bank-tabs').addEventListener('click', (e) => {
                if (e.target.matches('.token-bank-tab')) {
                    activeTokenCategory = e.target.dataset.category;
                    renderTokenBank();
                }
            });
            // Token Preset File Loading
            document.getElementById('save-token-presets-btn').addEventListener('click', saveTokenPresetsToFile);
            document.getElementById('load-token-data-input').addEventListener('change', handleTokensLoadFromFile);

            // Active Token File Loading
            document.getElementById('save-active-token-btn').addEventListener('click', saveActiveTokenToFile);
            document.getElementById('load-active-token-input').addEventListener('change', handleActiveTokenLoadFromFile);
        }

        function addTokenFromPreset(name, imageUrl) {
            const activeMap = getActiveMap();
            if (!activeMap) return;
            // Find the full token data in the presets to get abilities, etc.
            const presetToken = vttState.presetTokens[activeTokenCategory]?.find(t => t.name === name) || {};

            const newToken = {
                id: crypto.randomUUID(),
                name,
                color: presetToken.color || '#ff0000', // fallback color
                imageUrl,
                x: activeMap.width / 2,
                y: activeMap.height / 2,
                width: activeMap.grid.size || 50,
                height: activeMap.grid.size || 50,
                statusEffects: [],
                hp: presetToken.hp || 10,
                maxHp: presetToken.maxHp || 10,
                ac: presetToken.ac || 10,
                notes: presetToken.notes || '',
                ownedBy: 'dm',
                abilities: presetToken.abilities || [],
                visionRange: presetToken.visionRange || 30, // DEFAULT: 30 feet
            };
            if (!activeMap.tokens) activeMap.tokens = [];
            activeMap.tokens.push(newToken);
            updateDoc(vttDocRef, { maps: vttState.maps });
            sendChatMessage(`${currentUsername} added a ${name} token to the map.`, 'system');
        }

        function setupDrawingControls() { 
            // 2. Color Input (DM-Only)
            const colorInput = document.getElementById('drawing-color-input');
            colorInput.addEventListener('input', (e) => {
                if (!isDM) return;
                const activeMap = getActiveMap();
                if (!activeMap) return;
                // Live update the value, but defer Firestore update
                activeMap.drawing.color = e.target.value; 
            });
            colorInput.addEventListener('change', (e) => {
                if (!isDM) return;
                updateDoc(vttDocRef, { maps: vttState.maps });
            });

            // 3. Thickness Input (DM-Only)
            const thicknessInput = document.getElementById('drawing-thickness-input');
            const thicknessDisplay = document.getElementById('drawing-thickness-display');
            thicknessInput.addEventListener('input', (e) => {
                if (!isDM) return;
                const activeMap = getActiveMap();
                if (!activeMap) return;
                activeMap.drawing.thickness = parseInt(e.target.value, 10);
                thicknessDisplay.textContent = e.target.value;
            });
            thicknessInput.addEventListener('change', (e) => {
                if (!isDM) return;
                updateDoc(vttDocRef, { maps: vttState.maps });
            });

            // 4. Clear Drawing
            document.getElementById('clear-drawing-btn').addEventListener('click', () => {
                if (!isDM) return;
                showModal("Clear Drawings?", "This will permanently erase all free-hand drawings on this map.", () => {
                    const activeMap = getActiveMap();
                    if (activeMap) {
                        activeMap.drawing.lines = [];
                        updateDoc(vttDocRef, { maps: vttState.maps });
                    }
                });
            });
        }
        
        function renderDrawingControls() { 
            const activeMap = getActiveMap();
            if (activeMap && activeMap.drawing) {
                document.getElementById('drawing-color-input').value = activeMap.drawing.color;
                document.getElementById('drawing-thickness-input').value = activeMap.drawing.thickness;
                document.getElementById('drawing-thickness-display').textContent = activeMap.drawing.thickness;
            }
        }

        // --- NEW: Dice Roll Handler ---
        function handleDiceRoll(input) {
            const rollRegex = /(^\/roll |^\/r )(?<expression>\d+d\d+([\+\-]\d+)?)/i;
            const match = input.match(rollRegex);

            if (!match) return false;

            const expression = match.groups.expression;
            const parts = expression.split(/d|\+|-/);
            
            const numDice = parseInt(parts[0]) || 1;
            const numSides = parseInt(parts[1]) || 20;
            let modifier = 0;
            
            // Check for modifier (it's the third part, if it exists)
            const modMatch = expression.match(/[\+\-]\d+/);
            if (modMatch) {
                modifier = parseInt(modMatch[0]);
            }
            
            let total = 0;
            const rolls = [];
            
            for (let i = 0; i < numDice; i++) {
                const roll = Math.floor(Math.random() * numSides) + 1;
                rolls.push(roll);
                total += roll;
            }

            const totalWithMod = total + modifier;
            const modDisplay = modifier > 0 ? ` + ${modifier}` : (modifier < 0 ? ` - ${Math.abs(modifier)}` : '');
            
            const resultText = `rolled ${numDice}d${numSides}${modDisplay}: (${rolls.join(' + ')}${modDisplay}) = **${totalWithMod}** (Natural Roll: ${total})`;
            
            sendChatMessage(resultText, 'roll');
            return true;
        }


        function setupToolControls() {
            // --- File Controls ---
            document.getElementById('sync-data-btn').addEventListener('click', () => {
                setDoc(vttDocRef, vttState).then(() => {
                    const btn = document.getElementById('sync-data-btn');
                    const originalText = btn.textContent;
                    btn.textContent = 'Synced!';
                    btn.classList.add('bg-green-700');
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.classList.remove('bg-green-700');
                    }, 1500);
                }).catch(console.error);
            });
            
            // FIX: Updated Clear All button handler
            document.getElementById('clear-all-btn').addEventListener('click', () => { 
                showModal("Clear All Data?", "This will reset the entire session to its initial state, deleting all maps, tokens, and journal entries. Are you sure?", clearAllData); 
            });

            document.getElementById('save-data-file-btn').addEventListener('click', saveDataToFile);
            document.getElementById('load-data-file-input').addEventListener('change', loadDataFromFile);

            // Active Map File Controls
            document.getElementById('save-active-map-btn').addEventListener('click', saveActiveMapToFile);
            document.getElementById('load-map-data-input').addEventListener('change', handleMapLoadFromFile);

            // --- Core Tool Activation (Ruler, Draw, Erase) ---
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    // Use closest to ensure the click handler works even if clicking a child element (e.g. ‚úèÔ∏è)
                    const clickedButton = e.target.closest('.tool-btn'); 
                    if (!clickedButton) return;
                    
                    const tool = clickedButton.dataset.tool;
                    if (!tool) return;
                    
                    if (activeTool === tool) {
                        setActiveTool('pan');
                    } else {
                        setActiveTool(tool);
                    }
                });
            });
            
            document.getElementById('spell-templates-panel').addEventListener('click', (e) => {
                if(e.target.matches('.template-btn')) {
                    const shape = e.target.dataset.template;
                    if (activeTemplateShape === shape) {
                        setActiveTool('pan');
                    } else {
                        activeTemplateShape = shape;
                        setActiveTool('template');
                    }
                }
            });
            document.getElementById('clear-templates-btn').addEventListener('click', () => {
                const activeMap = getActiveMap();
                if (!activeMap) return;
                showModal("Clear Spell Templates?", "This will remove all templates from the current map.", () => {
                    activeMap.spellTemplates = [];
                    updateDoc(vttDocRef, { maps: vttState.maps });
                });
            });
            document.getElementById('template-color-input').addEventListener('input', (e) => {
                const activeMap = getActiveMap();
                if (!activeMap || !selectedElement || selectedElement.type !== 'template') return;
                const template = activeMap.spellTemplates.find(t => t.id === selectedElement.id);
                if (template) {
                    template.color = e.target.value + '80'; // Add alpha
                    redrawOverlayCanvas(); // Live preview
                }
            });
            document.getElementById('template-color-input').addEventListener('change', (e) => {
                    const activeMap = getActiveMap();
                if (!activeMap || !selectedElement || selectedElement.type !== 'template') return;
                    const template = activeMap.spellTemplates.find(t => t.id === selectedElement.id);
                if (template) {
                        template.color = e.target.value + '80'; // Add alpha
                        updateDoc(vttDocRef, { maps: vttState.maps });
                }
            });

            // --- UPDATED Chat Listener to handle /roll syntax ---
            document.getElementById('send-chat').addEventListener('click', () => { 
                const input = document.getElementById('chat-input'); 
                const messageText = input.value.trim();

                if (!messageText) return;

                const isRoll = handleDiceRoll(messageText);

                if (!isRoll) {
                    sendChatMessage(messageText);
                }
                
                input.value = ''; 
            });
            document.getElementById('chat-input').addEventListener('keypress', (e) => { 
                if (e.key === 'Enter') document.getElementById('send-chat').click(); 
            });
            // --- END UPDATED Chat Listener ---
            
            document.getElementById('clear-chat-btn').addEventListener('click', () => showModal("Clear Chat Log?", "Are you sure?", () => updateDoc(vttDocRef, { chatMessages: [] }) ));
            document.querySelectorAll('.dice-roll-btn').forEach(btn => btn.addEventListener('click', () => { 
                const die = btn.dataset.die; 
                const sides = parseInt(die.substring(1)); 
                const result = Math.floor(Math.random() * sides) + 1; 
                sendChatMessage(`rolled a ${die}: **${result}**`, 'roll'); 
            }));
            document.getElementById('add-to-tracker').addEventListener('click', () => { 
                const input = document.getElementById('turn-tracker-input'); 
                const name = input.value.trim(); 
                if (name && !(vttState.turnTracker.order || []).includes(name)) { 
                    const newOrder = [...(vttState.turnTracker.order || []), name]; 
                    const newTracker = {...vttState.turnTracker, order: newOrder}; 
                    if(newTracker.currentIndex === -1) newTracker.currentIndex = 0; 
                    updateDoc(vttDocRef, { turnTracker: newTracker }); 
                    input.value = ''; 
                } 
            });
            document.getElementById('next-turn').addEventListener('click', () => { 
                const tracker = vttState.turnTracker; 
                if (!tracker.order || tracker.order.length === 0) return; 
                let nextIndex = (tracker.currentIndex + 1) % tracker.order.length; 
                updateDoc(vttDocRef, { 'turnTracker.currentIndex': nextIndex }); 
            });
            document.getElementById('prev-turn').addEventListener('click', () => { 
                const tracker = vttState.turnTracker; 
                if (!tracker.order || tracker.order.length === 0) return; 
                let prevIndex = tracker.currentIndex - 1; 
                if (prevIndex < 0) prevIndex = tracker.order.length - 1; 
                updateDoc(vttDocRef, { 'turnTracker.currentIndex': prevIndex }); 
            });
            document.getElementById('reset-turn').addEventListener('click', () => { 
                const newIndex = (vttState.turnTracker.order || []).length > 0 ? 0 : -1; 
                updateDoc(vttDocRef, { 'turnTracker.currentIndex': newIndex }); 
            });


        }
        
        function downloadJSON(data, filename) {
            const dataStr = JSON.stringify(data, null, 2);
            const dataBlob = new Blob([dataStr], {type: "application/json"});
            const url = URL.createObjectURL(dataBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            sendChatMessage(`Successfully saved data to ${filename}`, 'system');
        }

        function saveActiveMapToFile() {
            const activeMap = getActiveMap();
            if (!activeMap) {
                sendChatMessage("No active map to save.", "system");
                return;
            }
            // Sanitize map object: remove the transform property as it's volatile/session-specific
            const { transform, ...mapData } = activeMap;
            downloadJSON(mapData, `gruvhub-map-${activeMap.name.replace(/\s/g, '_')}-${new Date().toISOString().slice(0,10)}.json`);
        }
        
        function saveActiveTokenToFile() {
            if (!selectedElement || selectedElement.type !== 'token') {
                sendChatMessage("Please select a token to save.", "system");
                return;
            }
            const token = getActiveToken(selectedElement.id);
            if (!token) return;

            // Remove positional data, as it's likely map-specific and we're saving the token's stats/identity.
            const { x, y, width, height, ...tokenData } = token;
            downloadJSON(tokenData, `gruvhub-token-${token.name.replace(/\s/g, '_')}-${new Date().toISOString().slice(0,10)}.json`);
        }

        function saveTokenPresetsToFile() {
            if (!vttState.presetTokens) {
                sendChatMessage("No token presets to save.", "system");
                return;
            }
            downloadJSON(vttState.presetTokens, `gruvhub-token-presets-${new Date().toISOString().slice(0,10)}.json`);
        }

        function saveDataToFile() {
            if (!vttState) {
                console.error("No data to save.");
                sendChatMessage("There is no session data to save.", "system");
                return;
            }
            // Exclude chat messages before saving for a cleaner state save
            const saveState = JSON.parse(JSON.stringify(vttState));
            delete saveState.chatMessages; 
            
            downloadJSON(saveState, `gruvhub-vtt-session-${new Date().toISOString().slice(0,10)}.json`);
        }

        function loadJSONFromFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const parsed = JSON.parse(e.target.result);
                        resolve(parsed);
                    } catch (error) {
                        reject(new Error(`Failed to parse JSON: ${error.message}`));
                    }
                };
                reader.onerror = () => reject(new Error("Error reading file."));
                reader.readAsText(file);
            });
        }

        function loadImageFromFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        resolve({
                            url: e.target.result,
                            width: img.naturalWidth,
                            height: img.naturalHeight
                        });
                    };
                    img.onerror = () => reject(new Error("Failed to load image content."));
                    img.src = e.target.result;
                };
                reader.onerror = () => reject(new Error("Error reading image file."));
                reader.readAsDataURL(file); // Use Data URL for local file display
            });
        }
        
        async function handleMapLoadFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const activeMap = getActiveMap();
            if (!activeMap) {
                sendChatMessage("ERROR: No active map is selected to load into.", "system");
                event.target.value = '';
                return;
            }

            try {
                if (file.type.startsWith('image/')) {
                    // --- Load Image File ---
                    const { url, width, height } = await loadImageFromFile(file);

                    showModal(
                        "Load Map Image?",
                        `This will set the map background to **${file.name}** (${width}x${height}). Note: This uses a local data URL and **will not persist for other users or on refresh** unless the image is hosted online. Are you sure?`,
                        () => {
                            const updatedMaps = vttState.maps.map(m => {
                                if (m.id === activeMap.id) {
                                    // Use data URL but persist other settings
                                    return { ...m, url: url, width: width, height: height };
                                }
                                return m;
                            });
                            
                            updateDoc(vttDocRef, { maps: updatedMaps })
                                .then(() => sendChatMessage(`Active map image loaded successfully from **${file.name}** (Local Data).`, "system"))
                                .catch(err => {
                                    console.error("Error updating map image state:", err);
                                    sendChatMessage("ERROR: Could not set new map image URL.", "system");
                                });
                        }
                    );
                } else if (file.type === 'application/json' || file.name.endsWith('.json')) {
                    // --- Load JSON File ---
                    const loadedMap = await loadJSONFromFile(file);
                    
                    // Simple validation for a map object
                    if (typeof loadedMap !== 'object' || !loadedMap.url || !loadedMap.id || !Array.isArray(loadedMap.tokens)) {
                        throw new Error("Invalid map JSON data structure.");
                    }

                    showModal(
                        "Load Map Data?",
                        `This will **OVERWRITE** the current active map's full state (tokens, fog, grid) with data from **${file.name}**. Are you sure?`,
                        () => {
                            // Merge loaded data into the active map, keeping its original ID and list index
                            const updatedMaps = vttState.maps.map(m => {
                                if (m.id === activeMap.id) {
                                    // Keep the current map's ID, but update everything else from the loaded file.
                                    return { 
                                        ...m, 
                                        ...loadedMap, 
                                        id: m.id, 
                                        transform: activeMap.transform || { scale: 1, panX: 0, panY: 0 },
                                        drawing: loadedMap.drawing || DEFAULT_STATE.maps[0].drawing, // Include drawing data
                                        fowEnabled: typeof loadedMap.fowEnabled === 'undefined' ? true : loadedMap.fowEnabled, // Include fowEnabled
                                    };
                                }
                                return m;
                            });
                            
                            updateDoc(vttDocRef, { maps: updatedMaps })
                                .then(() => sendChatMessage(`Active map data loaded successfully from **${file.name}**.`, "system"))
                                .catch(err => {
                                    console.error("Error updating map state:", err);
                                    sendChatMessage("ERROR: Could not load map data to the session.", "system");
                                });
                        }
                    );
                } else {
                    throw new Error("Unsupported file type. Please upload a JSON file or an image.");
                }
            } catch (error) {
                console.error("Failed to load map file:", error);
                sendChatMessage(`ERROR loading map file: ${error.message}`, "system");
            } finally {
                event.target.value = '';
            }
        }

        async function handleActiveTokenLoadFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!selectedElement || selectedElement.type !== 'token') {
                sendChatMessage("Please select a token to load data into.", "system");
                event.target.value = '';
                return;
            }

            const activeToken = getActiveToken(selectedElement.id);
            if (!activeToken) return;

            try {
                if (file.type.startsWith('image/')) {
                    // --- Load Image File to change token appearance ---
                    const { url } = await loadImageFromFile(file);

                    const updatedMaps = vttState.maps.map(m => {
                        if (m.id === getActiveMap().id) {
                            const newTokens = m.tokens.map(t => {
                                if (t.id === activeToken.id) {
                                    return { ...t, imageUrl: url };
                                }
                                return t;
                            });
                            return { ...m, tokens: newTokens };
                        }
                        return m;
                    });
                    
                    updateDoc(vttDocRef, { maps: updatedMaps })
                        .then(() => sendChatMessage(`Token image updated successfully from **${file.name}** (Local Data).`, "system"))
                        .catch(err => {
                            console.error("Error updating token image state:", err);
                            sendChatMessage("ERROR: Could not set new token image URL.", "system");
                        });

                } else if (file.type === 'application/json' || file.name.endsWith('.json')) {
                    // --- Load JSON Data to change token stats ---
                    const loadedTokenData = await loadJSONFromFile(file);

                    // Simple validation for token data structure
                    if (typeof loadedTokenData !== 'object' || !loadedTokenData.name || loadedTokenData.id) {
                        throw new Error("Invalid token JSON format (missing key fields or unexpected 'id' field).");
                    }

                    showModal(
                        "Load Token Data?",
                        `This will **OVERWRITE** the HP, AC, Notes, and Abilities of **${activeToken.name}** with data from **${file.name}**. Are you sure?`,
                        () => {
                            const activeMap = getActiveMap();
                            const tokenId = selectedElement.id;
                            
                            const updatedMaps = vttState.maps.map(m => {
                                if (m.id === activeMap.id) {
                                    const newTokens = m.tokens.map(t => {
                                        if (t.id === tokenId) {
                                            // Merge, but preserve map-specific data (x, y, width, height, id, ownedBy)
                                            return {
                                                ...t,
                                                ...loadedTokenData,
                                                id: t.id,
                                                x: t.x,
                                                y: t.y,
                                                width: t.width,
                                                height: t.height,
                                                ownedBy: t.ownedBy
                                            };
                                        }
                                        return t;
                                    });
                                    return { ...m, tokens: newTokens };
                                }
                                return m;
                            });
                            
                            updateDoc(vttDocRef, { maps: updatedMaps })
                                .then(() => sendChatMessage(`Token data loaded successfully into ${loadedTokenData.name} from **${file.name}**.`, "system"))
                                .catch(err => {
                                    console.error("Error updating token state:", err);
                                    sendChatMessage("ERROR: Could not load token data to the session.", "system");
                                });
                        }
                    );

                } else {
                    throw new Error("Unsupported file type. Please upload an image or a JSON file.");
                }
            } catch (error) {
                console.error("Failed to load active token file:", error);
                sendChatMessage(`ERROR loading active token file: ${error.message}`, "system");
            } finally {
                event.target.value = '';
            }
        }


        async function handleTokensLoadFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const loadedPresets = await loadJSONFromFile(file);

                // Simple validation for token presets structure (expecting an object with string keys and array values)
                if (typeof loadedPresets !== 'object' || !Object.values(loadedPresets).every(Array.isArray)) {
                    throw new Error("Invalid token presets data structure.");
                }

                showModal(
                    "Load Token Presets?",
                    `This will **OVERWRITE** the entire Token Bank Presets with the data from **${file.name}**. Are you sure?`,
                    () => {
                        updateDoc(vttDocRef, { presetTokens: loadedPresets })
                            .then(() => sendChatMessage(`Token Presets loaded successfully from **${file.name}**.`, "system"))
                            .catch(err => {
                                console.error("Error updating token presets:", err);
                                sendChatMessage("ERROR: Could not load token presets to the session.", "system");
                            });
                    }
                );
            } catch (error) {
                console.error("Failed to load token presets file:", error);
                sendChatMessage(`ERROR loading token presets file: ${error.message}`, "system");
            } finally {
                event.target.value = '';
            }
        }


        function loadDataFromFile(event) {
            const file = event.target.files[0];
            if (!file) { return; }
            
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const loadedState = JSON.parse(e.target.result);
                    if (loadedState && Array.isArray(loadedState.maps) && loadedState.activeMapId) {
                        showModal(
                            "Load Session Data?", 
                            "This will OVERWRITE the current session with the data from the file. This will affect all connected users. Are you sure?",
                            () => {
                                setDoc(vttDocRef, loadedState)
                                    .then(() => sendChatMessage("Session data successfully loaded from file.", "system"))
                                    .catch(err => {
                                        console.error("Error loading data to Firestore:", err);
                                        sendChatMessage("ERROR: Could not load data to the session.", "system");
                                    });
                            }
                        );
                    } else {
                        throw new Error("Invalid file format.");
                    }
                } catch (error) {
                    console.error("Failed to load or parse file:", error);
                    sendChatMessage(`ERROR: Failed to load file. ${error.message}`, "system");
                } finally {
                    event.target.value = '';
                }
            };
            
            reader.onerror = function(e) {
                console.error("Error reading file:", e);
                sendChatMessage("ERROR: Could not read the selected file.", "system");
                event.target.value = '';
            };
            
            reader.readAsText(file);
        }

        function setActiveTool(tool) {
            activeTool = tool;
            
            rulerState.active = false;
            canvasInteraction.active = false;
            if (tool !== 'template') activeTemplateShape = null;
            if (tool !== 'pan') { selectedElement = null; render(); }

            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            if (tool !== 'pan') {
                 document.querySelector(`[data-tool="${tool}"]`)?.classList.add('active');
            }
            
            document.querySelectorAll('.template-btn').forEach(btn => {
                btn.classList.toggle('active', tool === 'template' && activeTemplateShape === btn.dataset.template);
            });
            document.querySelectorAll('.effect-btn').forEach(btn => btn.classList.remove('active'));
            armedEffect = null;


            const mapContainer = document.getElementById('map-container');
            switch(tool) {
                case 'ruler':
                case 'draw': // NEW
                case 'erase': // NEW
                case 'template':
                    mapContainer.style.cursor = 'crosshair';
                    break;
                case 'pan':
                default:
                    mapContainer.style.cursor = 'move';
                    break;
            }
            redrawOverlayCanvas(); // Master redraw
        }

        function handleMapMouseDown(e) {
            if (e.button !== 0) return;
            const coords = getMapCoords(e);
            const activeMap = getActiveMap();
            if (!activeMap) return;

            // --- 1. Drawing/Erasing (NEW) ---
            if ((activeTool === 'draw' || activeTool === 'erase') && isDM) {
                isDrawing = true;
                
                // Use the map's persistent settings for the drawing
                const { color, thickness } = activeMap.drawing;
                
                currentLine = {
                    points: [coords],
                    color: activeTool === 'draw' ? color : 'rgba(0,0,0,1)', // Use map color for draw
                    thickness: thickness,
                    mode: activeTool // 'draw' or 'erase'
                };

                // Set up canvas context for drawing/erasing immediately
                overlayCtx.strokeStyle = currentLine.color;
                overlayCtx.lineWidth = currentLine.thickness / activeMap.transform.scale;
                overlayCtx.lineCap = 'round';
                overlayCtx.lineJoin = 'round';
                if (activeTool === 'erase') {
                     overlayCtx.globalCompositeOperation = 'destination-out';
                } else {
                     overlayCtx.globalCompositeOperation = 'source-over';
                }

                overlayCtx.beginPath();
                overlayCtx.moveTo(coords.x, coords.y);
                
                e.stopPropagation();
                return;
            }

            // --- 2. Ruler ---
            if (activeTool === 'ruler') {
                rulerState.active = true;
                rulerState.start = coords;
                rulerState.end = coords;
                e.stopPropagation();
                return;
            }
            
            // --- 3. Template/Pan Logic ---
            if (activeTool === 'template') {
                if (isDM) {
                     placeSpellTemplate(e);
                }
                e.stopPropagation();
                return;
            }
            
            // Default: Pan/Select
            if (activeTool === 'pan') {
                if (isDM) {
                    // DM-only Template interaction check
                    const template = getTemplateAt(coords.x, coords.y);
                    if (template) {
                        selectedElement = { type: 'template', id: template.id };
                        const handle = getResizeHandleForTemplate(template, coords.x, coords.y);
                        canvasInteraction = {
                            active: true,
                            type: handle ? 'resize' : 'drag',
                            targetId: template.id,
                            handle: handle,
                            startPos: coords,
                            startDims: { ...template }
                        };
                        redrawOverlayCanvas();
                        e.stopPropagation();
                        return;
                    }
                }
                // Map Panning Initiation (DM ONLY, only if not clicking a token/fog)
                if (isDM && e.target.closest('.map-token, .fog-block, .resize-handle') === null) {
                    isPanning = true;
                    lastPanPoint = { x: e.clientX, y: e.clientY };
                    document.getElementById('map-container').style.cursor = 'grabbing';
                }
            }
        }

        function handleMapMouseMove(e) {
            const coords = getMapCoords(e);

            // 1. Template Interaction (DM Only)
            if (canvasInteraction.active && isDM) {
                const activeMap = getActiveMap();
                if (!activeMap) return;
                const template = activeMap.spellTemplates.find(t => t.id === canvasInteraction.targetId);
                if (!template) return;

                if (canvasInteraction.type === 'drag') {
                    const dx = coords.x - canvasInteraction.startPos.x;
                    const dy = coords.y - canvasInteraction.startPos.y;
                    template.x = canvasInteraction.startDims.x + dx;
                    template.y = canvasInteraction.startDims.y + dy;
                } else if (canvasInteraction.type === 'resize') {
                    const dx = coords.x - template.x;
                    const dy = coords.y - template.y;
                    const newRadius = Math.sqrt(dx*dx + dy*dy);
                    if (template.type === 'circle') template.radius = Math.max(10, newRadius);
                    else if (template.type === 'square') template.size = Math.max(20, Math.abs(dx)*2, Math.abs(dy)*2);
                    else if (template.type === 'cone') template.height = Math.max(20, dy);
                }
                redrawOverlayCanvas();

            // 2. Ruler
            } else if (rulerState.active) {
                rulerState.end = coords;
                redrawOverlayCanvas();

            // 3. Drawing/Erasing (NEW)
            } else if (isDrawing && isDM) {
                if (!currentLine) return;
                currentLine.points.push(coords);
                
                // Draw the line segment in real-time
                overlayCtx.lineTo(coords.x, coords.y); 
                overlayCtx.stroke(); 
                overlayCtx.beginPath(); 
                overlayCtx.moveTo(coords.x, coords.y); 

            // 4. Panning
            } else if (isPanning && isDM) { // Check isDM here to prevent players from moving map
                const activeMap = getActiveMap(); 
                if (!activeMap) return; 
                const dx = e.clientX - lastPanPoint.x; 
                const dy = e.clientY - lastPanPoint.y; 
                lastPanPoint = { x: e.clientX, y: e.clientY }; 
                activeMap.transform.panX += dx; 
                activeMap.transform.panY += dy; 
                // Don't call renderMap here, just update the map content transform property directly
                document.getElementById('map-content').style.transform = `translate(${activeMap.transform.panX}px, ${activeMap.transform.panY}px) scale(${activeMap.transform.scale})`;
                redrawOverlayCanvas(); // Redraw canvases (grid, fow, overlay) based on new pan/zoom state
            }
        }

        function handleMapMouseUp(e) {
            if (canvasInteraction.active) {
                canvasInteraction.active = false;
                updateDoc(vttDocRef, { maps: vttState.maps });
            }
            if (rulerState.active) {
                rulerState.active = false;
                setTimeout(() => {
                    if (!rulerState.active) { redrawOverlayCanvas(); }
                }, 2000);
            }

            // 3. Drawing/Erasing Finalization (NEW)
            if (isDrawing && isDM) {
                isDrawing = false;
                
                // Finalize line segment and add to map state
                const activeMap = getActiveMap();
                if (activeMap && currentLine && currentLine.points.length > 1) {
                    if (!activeMap.drawing.lines) activeMap.drawing.lines = [];
                    activeMap.drawing.lines.push(currentLine);
                    updateDoc(vttDocRef, { maps: vttState.maps });
                }
                currentLine = null;
                
                // Reset canvas context and redraw everything
                overlayCtx.globalCompositeOperation = 'source-over';
                redrawOverlayCanvas(); 
            }

            if (isPanning) {
                isPanning = false;
                document.getElementById('map-container').style.cursor = 'move';
                updateDoc(vttDocRef, { maps: vttState.maps });
            }
        }

        function clearOverlayCanvas() { // RENAMED
            if (overlayCtx) overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        }

        function redrawPersistentDrawing() { // NOW DRAWS TO overlayCtx
            const activeMap = getActiveMap();
            if (!activeMap || !overlayCtx) return;

            const lines = activeMap.drawing.lines || [];
            const scale = activeMap.transform.scale || 1;

            lines.forEach(line => {
                overlayCtx.lineWidth = (line.thickness || activeMap.drawing.thickness) / scale;
                overlayCtx.lineCap = 'round';
                overlayCtx.lineJoin = 'round';

                if (line.mode === 'erase') {
                    // Erase mode: destination-out clears everything already drawn in that spot
                    overlayCtx.globalCompositeOperation = 'destination-out';
                    overlayCtx.strokeStyle = 'rgba(0,0,0,1)'; 
                } else {
                    // Draw mode: source-over draws on top
                    overlayCtx.globalCompositeOperation = 'source-over';
                    overlayCtx.strokeStyle = line.color;
                }

                overlayCtx.beginPath();
                if (line.points.length > 0) {
                    overlayCtx.moveTo(line.points[0].x, line.points[0].y);
                    for (let i = 1; i < line.points.length; i++) {
                        overlayCtx.lineTo(line.points[i].x, line.points[i].y);
                    }
                }
                overlayCtx.stroke();
            });
            
            // Reset composite operation for templates and ruler
            overlayCtx.globalCompositeOperation = 'source-over';
        }
        
        function drawRuler() { // NOW DRAWS TO overlayCtx
            if (!rulerState.start || !rulerState.end) return;

            const { start, end } = rulerState;
            const activeMap = getActiveMap();
            if (!activeMap) return;

            overlayCtx.beginPath();
            overlayCtx.moveTo(start.x, start.y);
            overlayCtx.lineTo(end.x, end.y);
            overlayCtx.strokeStyle = '#ffd700';
            overlayCtx.lineWidth = 3 / activeMap.transform.scale;
            overlayCtx.setLineDash([10 / activeMap.transform.scale, 5 / activeMap.transform.scale]);
            overlayCtx.stroke();
            overlayCtx.setLineDash([]);
            
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const pixelDist = Math.sqrt(dx*dx + dy*dy);
            const gridSize = activeMap.grid.size || 50;
            const feetDist = Math.round((pixelDist / gridSize) * 5);

            overlayCtx.fillStyle = '#ffffff';
            overlayCtx.strokeStyle = '#000000';
            overlayCtx.lineWidth = 4 / activeMap.transform.scale;
            overlayCtx.font = `bold ${16 / activeMap.transform.scale}px Cinzel`;
            overlayCtx.textAlign = 'center';
            const text = `${feetDist} ft`;
            overlayCtx.strokeText(text, start.x + dx/2, start.y + dy/2 - 10);
            overlayCtx.fillText(text, start.x + dx/2, start.y + dy/2 - 10);
        }

        function placeSpellTemplate(e) {
            const activeMap = getActiveMap();
            if (!activeMap || !isDM || !activeTemplateShape) return;
            const { x, y } = getMapCoords(e);
            const gridSize = activeMap.grid.size || 50;
            
            let newTemplate = { id: crypto.randomUUID(), type: activeTemplateShape, x, y, color: document.getElementById('template-color-input').value + '80' };
            
            switch(activeTemplateShape) {
                case 'circle': newTemplate.radius = (20 / 5) * gridSize; break;
                case 'cone': newTemplate.height = (15 / 5) * gridSize; break;
                case 'square': newTemplate.size = (30 / 5) * gridSize; break;
            }

            if (!activeMap.spellTemplates) activeMap.spellTemplates = [];
            activeMap.spellTemplates.push(newTemplate);
            updateDoc(vttDocRef, { maps: vttState.maps });
            setActiveTool('pan');
        }

        function drawFoW() { // NEW FoW MASKING FUNCTION
            const activeMap = getActiveMap();
            if (!activeMap || !fowCtx) return;

            // --- TOGGLE CHECK ---
            if (!activeMap.fowEnabled) { 
                fowCtx.clearRect(0, 0, fowCanvas.width, fowCanvas.height);
                return;
            }
            // --- END TOGGLE CHECK ---

            fowCtx.clearRect(0, 0, fowCanvas.width, fowCanvas.height);
            const gridSize = activeMap.grid.size || 50;

            // 1. Draw the initial opaque fog layer
            fowCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            fowCtx.fillRect(0, 0, fowCanvas.width, fowCanvas.height);

            // 2. Set composite operation to punch holes (tokens reveal)
            fowCtx.globalCompositeOperation = 'destination-out';

            (activeMap.tokens || []).forEach(token => {
                // Tokens must be owned by the current user or be GMPC-owned to reveal vision for *this* client.
                const isTokenVisibleToClient = isDM || token.ownedBy === userId || token.ownedBy === DM_PLAYER_GMPC_ID;
                
                if (isTokenVisibleToClient) {
                    const visionRange = (token.visionRange || 0);
                    if (visionRange > 0) {
                        // Convert vision range (feet) to canvas pixels (5ft/grid unit)
                        const radius = (visionRange / 5) * gridSize;
                        
                        // Center of the token
                        const centerX = token.x + token.width / 2;
                        const centerY = token.y + token.height / 2;

                        fowCtx.beginPath();
                        fowCtx.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
                        fowCtx.fill();
                    }
                }
            });

            // 3. Reset composite operation
            fowCtx.globalCompositeOperation = 'source-over';
        }


        function redrawOverlayCanvas() { // MASTER REDRAW - RENAMED
            // 0. Update FOW layer first
            drawFoW(); 

            // 1. Clear the overlay (drawings/templates/ruler)
            clearOverlayCanvas(); 
            const activeMap = getActiveMap();
            if (!activeMap || !overlayCtx) return;

            const scale = activeMap.transform.scale || 1;

            // 2. Draw Persistent Drawings/Erasures
            redrawPersistentDrawing();

            // 3. Draw Spell Templates
            (activeMap.spellTemplates || []).forEach(template => {
                const isSelected = selectedElement && selectedElement.type === 'template' && selectedElement.id === template.id;
                
                overlayCtx.fillStyle = template.color;
                overlayCtx.strokeStyle = isSelected ? '#33C3FF' : '#FFD700';
                overlayCtx.lineWidth = (isSelected ? 4 : 2) / scale;
                
                overlayCtx.beginPath();
                switch(template.type) {
                    case 'circle':
                        overlayCtx.arc(template.x, template.y, template.radius, 0, 2 * Math.PI);
                        break;
                    case 'square':
                        overlayCtx.rect(template.x - template.size/2, template.y - template.size/2, template.size, template.size);
                        break;
                    case 'cone':
                        const coneHeight = template.height;
                        const coneWidth = template.height;
                        overlayCtx.moveTo(template.x, template.y);
                        overlayCtx.lineTo(template.x - coneWidth / 2, template.y + coneHeight);
                        overlayCtx.lineTo(template.x + coneWidth / 2, template.y + coneHeight);
                        overlayCtx.closePath();
                        break;
                }
                overlayCtx.fill();
                overlayCtx.stroke();

                if (isSelected && isDM) {
                    drawResizeHandle(getResizeHandleForTemplate(template));
                }
            });

            // 4. Draw Ruler Overlay
            drawRuler();
        }
        
        function drawResizeHandle(handle) {
            if (!handle) return;
            overlayCtx.fillStyle = '#33C3FF';
            overlayCtx.fillRect(handle.x - handle.size/2, handle.y - handle.size/2, handle.size, handle.size);
        }

        function getTemplateAt(x, y) {
            const activeMap = getActiveMap();
            if (!activeMap || !activeMap.spellTemplates) return null;
            for (let i = activeMap.spellTemplates.length - 1; i >= 0; i--) {
                const template = activeMap.spellTemplates[i];
                switch(template.type) {
                    case 'circle':
                        const dist = Math.sqrt(Math.pow(x - template.x, 2) + Math.pow(y - template.y, 2));
                        if (dist <= template.radius) return template;
                        break;
                    case 'square':
                        if (x >= template.x - template.size/2 && x <= template.x + template.size/2 &&
                            y >= template.y - template.size/2 && y <= template.y + template.size/2) {
                            return template;
                        }
                        break;
                    case 'cone':
                       if (x >= template.x - template.height/2 && x <= template.x + template.height/2 &&
                            y >= template.y && y <= template.y + template.height) {
                                return template;
                            }
                        break;
                }
            }
            return null;
        }

        function getResizeHandleForTemplate(template, clickX, clickY) {
            if (!template) return null;
            const scale = getActiveMap()?.transform.scale || 1;
            const handleSize = 10 / scale;
            let handlePos;

            switch(template.type) {
                case 'circle': handlePos = { x: template.x + template.radius, y: template.y }; break;
                case 'square': handlePos = { x: template.x + template.size/2, y: template.y + template.size/2 }; break;
                case 'cone': handlePos = { x: template.x, y: template.y + template.height }; break;
                default: return null;
            }

            const handle = { ...handlePos, size: handleSize };
            if (clickX === undefined) return handle;

            if (clickX >= handle.x - handleSize/2 && clickX <= handle.x + handleSize/2 &&
                clickY >= handle.y - handleSize/2 && clickY <= handle.y + handleSize/2) {
                return handle;
            }
            return null;
        }

        function renderTemplateControls() {
            const panel = document.getElementById('template-controls-panel');
            if (isDM && selectedElement && selectedElement.type === 'template') {
                panel.classList.remove('hidden');
                panel.classList.add('flex');
                const template = getActiveMap()?.spellTemplates.find(t => t.id === selectedElement.id);
                if (template) {
                    document.getElementById('template-color-input').value = template.color.substring(0, 7);
                }
            } else {
                panel.classList.add('hidden');
                panel.classList.remove('flex');
            }
        }

        // --- Embedded Audio Logic (Tabletop Audio Link Share) ---

        function setupEmbeddedAudioControls() {
            const urlInput = document.getElementById('audio-url-input');
            const linkDisplay = document.getElementById('current-audio-link');

            document.getElementById('set-audio-broadcast-btn').addEventListener('click', () => {
                const url = urlInput.value.trim();
                if (url) {
                    updateDoc(vttDocRef, { audioLink: url });
                    sendChatMessage(`${currentUsername} shared a new audio link (open in new tab to play).`, 'system');
                }
            });

            document.getElementById('clear-audio-broadcast-btn').addEventListener('click', () => {
                updateDoc(vttDocRef, { audioLink: null });
                urlInput.value = '';
                sendChatMessage(`${currentUsername} cleared the shared audio link.`, 'system');
            });
            
            // Set input value on first render if state has a link
            if (vttState.audioLink) {
                urlInput.value = vttState.audioLink;
            }
        }

        function syncEmbeddedAudio(audioLink) {
            const linkDisplay = document.getElementById('current-audio-link');
            const urlInput = document.getElementById('audio-url-input');

            if (audioLink) {
                // Update UI to show the shared link
                linkDisplay.textContent = audioLink;
                linkDisplay.href = audioLink;
                
                // Ensure the DM's input field is updated if it somehow got out of sync
                if (isDM && urlInput.value !== audioLink) {
                    urlInput.value = audioLink;
                }
            } else {
                // Clear the UI
                linkDisplay.textContent = "No audio link set.";
                linkDisplay.removeAttribute('href');
            }
        }


        // --- Battle System ---
        function setupBattleSystem() {
            document.getElementById('start-battle-btn').addEventListener('click', showBattleSetupModal);
            document.getElementById('battle-setup-cancel-btn').addEventListener('click', () => document.getElementById('battle-setup-modal').classList.add('hidden'));
            document.getElementById('begin-combat-btn').addEventListener('click', beginCombat);
            document.getElementById('roll-initiative-btn').addEventListener('click', rollInitiative);
            
            // FIX 1: Change 'End Battle' button to call the correct end function
            document.getElementById('end-battle-btn').addEventListener('click', () => {
                if(isDM) showModal("End Battle?", "Are you sure you want to end combat? Tokens HP will be saved.", endBattle); 
            });
            
            document.getElementById('battle-action-menu').addEventListener('click', handleBattleAction);
            document.getElementById('player-team').addEventListener('click', handleTargetSelection);
            document.getElementById('enemy-team').addEventListener('click', handleTargetSelection);
            document.getElementById('resort-initiative-btn').addEventListener('click', resortInitiative); // NEW DM BUTTON
        }

        function showBattleSetupModal() {
            const modal = document.getElementById('battle-setup-modal');
            const tokenList = document.getElementById('battle-setup-token-list');
            tokenList.innerHTML = '';
            const activeMap = getActiveMap();
            if (!activeMap || !activeMap.tokens || activeMap.tokens.length === 0) {
                tokenList.innerHTML = '<p class="text-gray-400">No tokens on the current map.</p>';
                modal.classList.remove('hidden');
                return;
            }
            activeMap.tokens.forEach(token => {
                let ownerName = 'Enemy';
                if (token.ownedBy === DM_PLAYER_GMPC_ID) {
                    ownerName = 'DM Player (GMPC)';
                } else if (token.ownedBy !== 'dm') {
                    ownerName = (activeUserList || []).find(u => u.id === token.ownedBy)?.username || 'Player';
                }
                const div = document.createElement('div');
                div.className = 'flex items-center gap-2 p-2 rounded hover:bg-[#6b4c4a]';
                // FIX: Re-adding the checkbox for selection, and cleaning up the layout.
                div.innerHTML = `
                    <input type="checkbox" data-token-id="${token.id}" class="gruvhub-input battle-setup-checkbox">
                    <div class="w-8 h-8 rounded-full bg-cover bg-center flex-shrink-0" style="background-image: url('${token.imageUrl}'); background-color: ${token.color};"></div>
                    <div class="flex-grow min-w-0">
                        <p class="text-sm font-bold truncate">${token.name}</p>
                        <p class="text-xs text-gray-400">Owner: ${ownerName}</p>
                    </div>
                    <input type="number" class="gruvhub-input w-16 p-1 text-center initiative-roll-input" data-token-id="${token.id}" placeholder="d20">
                `;
                tokenList.appendChild(div);
            });
            modal.classList.remove('hidden');
        }
        
        function rollInitiative() {
            // Updated to select the initiative inputs next to the checked boxes
            const initiativeInputs = document.querySelectorAll('#battle-setup-token-list .initiative-roll-input');
            initiativeInputs.forEach(input => {
                // Find the associated checkbox/token
                const tokenId = input.dataset.tokenId;
                const checkbox = document.querySelector(`.battle-setup-checkbox[data-token-id="${tokenId}"]`);

                // Rolling for all is easier for DM entry.
                if (input) {
                    input.value = Math.floor(Math.random() * 20) + 1;
                }
            });
        }

        function beginCombat() {
            // FIX: Now iterating over CHECKED boxes to get selected combatants
            const checkedBoxes = document.querySelectorAll('#battle-setup-token-list .battle-setup-checkbox:checked');

            const combatantData = Array.from(checkedBoxes).map(box => {
                const tokenId = box.dataset.tokenId;
                const token = getActiveMap().tokens.find(t => t.id === tokenId);
                
                // Find the corresponding initiative input value
                const initiativeInput = document.querySelector(`.initiative-roll-input[data-token-id="${tokenId}"]`);
                const initiative = parseInt(initiativeInput?.value, 10) || 0;

                return { token, initiative };
            });
            
            if (combatantData.length < 2) {
                showModal("Not enough combatants", "Please select at least two tokens to start a battle.", () => {});
                return;
            }
            
            // Sort by initiative, descending
            combatantData.sort((a, b) => b.initiative - a.initiative);

            const combatants = combatantData.map(data => {
                return { ...data.token, currentHP: data.token.hp, isDefeated: false, maxHp: data.token.maxHp || data.token.hp, initiative: data.initiative, activeEffects: [], needsProcessing: true };
            });
            
            const turnOrder = combatants.map(c => c.name);

            updateDoc(vttDocRef, {
                battle: {
                    isActive: true,
                    combatants: combatants,
                    turnIndex: 0,
                    log: [{ text: 'The battle begins!', type: 'system' }],
                    turnOrder: turnOrder,
                    turnTimerStartTime: serverTimestamp(), // START TIMER HERE
                    turnTimerDuration: vttState.battle.turnTimerDuration
                }
            });
            document.getElementById('battle-setup-modal').classList.add('hidden');
        }
        
        // NEW DM TOOL: Re-sort initiative
        function resortInitiative() {
            showModal("Re-Sort Initiative?", "Are you sure you want to re-sort the remaining combatants by initiative score? This action cannot be undone.", () => {
                const battle = JSON.parse(JSON.stringify(vttState.battle));

                // Filter out defeated combatants and re-sort
                const activeCombatants = battle.combatants.filter(c => !c.isDefeated);
                
                // Get the combatant's original token data (which has the initiative value)
                activeCombatants.sort((a, b) => b.initiative - a.initiative);

                // Merge back with defeated combatants (putting defeated at the end of the list)
                const defeatedCombatants = battle.combatants.filter(c => c.isDefeated);
                battle.combatants = [...activeCombatants, ...defeatedCombatants];
                
                battle.turnOrder = battle.combatants.map(c => c.name);
                battle.turnIndex = 0;
                battle.turnTimerStartTime = serverTimestamp();
                battle.log.push({ text: 'Initiative was re-sorted by the DM.', type: 'system' });
                
                // FIX 2: Save the ENTIRE updated battle object back to Firestore
                updateDoc(vttDocRef, { battle: battle });
             });
        }

        // NEW: Turn start logic to handle DoT/HoT and status effects
        // FIX 3: This logic is now only called once by executeAbility when the turn advances, 
        // ensuring DoT/HoT happens once per turn, not every second.
        function processTurnStart(combatant, updatedBattle) {
            let logTexts = [];
            let newEffects = [];
            let isStunned = false;

            // Use spread operator to create a shallow copy before modifying or iterating
            [...(combatant.activeEffects || [])].forEach(effect => {
                let effectLog = '';
                
                // 1. Check for stun/skip turn
                if (effect.name === 'stunned') {
                    isStunned = true;
                    effectLog += `${combatant.name} is stunned and skips their turn.`;
                }

                // 2. Apply DoT/HoT damage/healing
                if (effect.type === 'dot' || effect.type === 'hot') {
                    const amount = Math.floor(Math.random() * (effect.damageRange[1] - effect.damageRange[0] + 1)) + effect.damageRange[0];
                    if (effect.type === 'dot') {
                        combatant.currentHP = Math.max(0, combatant.currentHP - amount);
                        effectLog += `üî• ${combatant.name} takes ${amount} damage from ${effect.name}.`;
                    } else {
                        combatant.currentHP = Math.min(combatant.maxHp, combatant.currentHP + amount);
                        effectLog += `‚ú® ${combatant.name} heals ${amount} HP from ${effect.name}.`;
                    }
                }
                
                // 3. Decrease duration and check for expiration
                effect.duration--;
                if (effect.duration > 0) {
                    newEffects.push(effect);
                } else {
                    effectLog += ` ${effect.name} wears off.`;
                }
                
                if (effectLog) updatedBattle.log.push({ text: effectLog, type: 'battle' });
            });

            combatant.activeEffects = newEffects;
            
            // Check for defeat after damage
            if (combatant.currentHP <= 0) {
                combatant.isDefeated = true;
                updatedBattle.log.push({ text: `${combatant.name} has been defeated by a lingering effect!`, type: 'battle' });
            }
            
            return isStunned;
        }

        function renderBattleScreen() {
             const battle = vttState.battle;
             if (!battle || !battle.isActive) return;

             const battleDmControls = document.querySelector('#battle-screen .dm-controls-wrapper');
             if (isDM) {
                 battleDmControls.classList.remove('hidden');
                 battleDmControls.style.display = 'flex';
             } else {
                 battleDmControls.classList.add('hidden');
                 battleDmControls.style.display = 'none';
             }
             
             // --- START TURN PROCESSING FOR DM ONLY (DoT/HoT logic moved here) ---
             // Note: This block runs every time the Firestore state updates, which includes once per turn.
             const currentTurnCombatant = battle.combatants[battle.turnIndex];
             
             if (isDM && battle.turnTimerStartTime && battle.turnTimerStartTime.toMillis) {
                 const updatedBattleForProcessing = JSON.parse(JSON.stringify(battle));
                 const combatantForProcessing = updatedBattleForProcessing.combatants[battle.turnIndex];
                 
                 // Use a flag to track if effects have been processed for the current turn.
                 // This ensures the processing happens when the turn *first* lands on the combatant 
                 // (i.e., when turnIndex changes), and not repeatedly by the timer or other updates.
                 if (combatantForProcessing.needsProcessing !== false) {
                     const isStunned = processTurnStart(combatantForProcessing, updatedBattleForProcessing);

                     // Set the flag to false so it doesn't process again on the same turnIndex
                     updatedBattleForProcessing.combatants[battle.turnIndex].needsProcessing = false;

                     if (isStunned) {
                         // Apply the processed state, then immediately advance turn via executeAbility (null ability)
                         updateDoc(vttDocRef, { battle: updatedBattleForProcessing })
                             .then(() => executeAbility(currentTurnCombatant, null, null));
                         return; // Skip rendering/waiting for action this client loop while the turn is automatically ending
                     }

                     // Save any necessary DoT/HoT damage back to Firestore
                     if (updatedBattleForProcessing.log.length > battle.log.length) {
                          updateDoc(vttDocRef, { battle: updatedBattleForProcessing });
                     }
                 }
             }
             // --- END TURN PROCESSING ---


             const playerTeamEl = document.getElementById('player-team');
             const enemyTeamEl = document.getElementById('enemy-team');
             const turnOrderEl = document.getElementById('battle-turn-order');
             const actionMenuEl = document.getElementById('battle-action-menu');

             playerTeamEl.innerHTML = '';
             enemyTeamEl.innerHTML = '';
             
             let turnStatusHtml = `Current Turn: <strong>${currentTurnCombatant.name}</strong>`;

             // --- TIMER LOGIC (Client-Side Update) ---
             if (battle.turnTimerStartTime && battle.turnTimerDuration > 0) {
                 let remainingSeconds = battle.turnTimerDuration;

                 if (battle.turnTimerStartTime.toMillis) {
                     const startTime = battle.turnTimerStartTime.toMillis();
                     const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
                     remainingSeconds = battle.turnTimerDuration - elapsedSeconds;
                 }
                 
                 const minutes = Math.floor(Math.max(0, remainingSeconds) / 60);
                 const seconds = Math.abs(Math.max(0, remainingSeconds)) % 60; // Use max(0, remainingSeconds)

                 const timerDisplay = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;

                 turnStatusHtml += ` <span class="text-3xl font-bold ${remainingSeconds <= 10 ? 'text-red-400' : 'text-yellow-300'} ml-4">(${timerDisplay})</span>`;

                 if (remainingSeconds <= 0 && isDM) {
                     // Auto-end turn if time runs out (only DM executes the change to avoid race condition)
                     executeAbility(currentTurnCombatant, null, null); 
                     return; 
                 }
                 
                 // Clear existing interval and set a new one if necessary
                 if (!battleTimerInterval) {
                     clearInterval(battleTimerInterval);
                     battleTimerInterval = setInterval(() => {
                         // Force a client-side render to update the time display every second
                         render(); 
                     }, 1000);
                 }
             } else if (battleTimerInterval) {
                 clearInterval(battleTimerInterval);
                 battleTimerInterval = null;
             }
             // --- END TIMER LOGIC ---

             turnOrderEl.innerHTML = turnStatusHtml; // Use innerHTML for formatting

             battle.combatants.forEach((c, index) => {
                 // Determine team: Player Team if ownedBy is NOT 'dm'
                 const isPlayer = c.ownedBy !== 'dm';
                 const teamEl = isPlayer ? playerTeamEl : enemyTeamEl;
                 
                 const card = document.createElement('div');
                 card.className = 'combatant-card';
                 card.dataset.id = c.id;

                 const healthPercentage = Math.max(0, (c.currentHP / c.maxHp) * 100);
                 const healthClass = healthPercentage > 60 ? 'high' : healthPercentage > 30 ? 'medium' : 'low';
                 
                 // Render active status effects icons
                 const effectIcons = (c.activeEffects || []).map(e => {
                     const icon = STATUS_ICONS[e.name] || '?';
                     const durationText = e.duration ? `(${e.duration}T)` : '';
                     return `<span title="${e.name} ${durationText}" class="text-lg">${icon}</span>`;
                 }).join('');

                 card.innerHTML = `
                             <div>
                                 <div class="combatant-image" style="background-image: url('${c.imageUrl}'); background-color: ${c.color};"></div>
                                 <h4 class="font-bold">${c.name}</h4>
                             </div>
                             <div>
                                 <p class="text-xs mb-1">HP: ${c.currentHP} / ${c.maxHp}</p>
                                 <div class="combatant-health-bar">
                                     <div class="combatant-health-fill ${healthClass}" style="width: ${healthPercentage}%;"></div>
                                 </div>
                                 <div class="status-effect-box flex justify-center gap-1">${effectIcons}</div>
                             </div>
                             `;

                 if (index === battle.turnIndex) card.classList.add('active-turn');
                 if (c.isDefeated) card.classList.add('defeated');

                 teamEl.appendChild(card);
             });
             
             renderActionMenu(actionMenuEl, currentTurnCombatant);
             updateTargetingUI(currentTurnCombatant);
             
             const logEl = document.getElementById('battle-log');
             logEl.innerHTML = (battle.log || []).slice(-10).map(entry => `<p class="mb-1">${entry.text}</p>`).join('');
             logEl.scrollTop = logEl.scrollHeight;
        }
        
        // --- Battle System --- (Continued)
        
        function renderActionMenu(container, combatant) {
            container.innerHTML = '';
            const isMyTurn = (isDM || combatant.ownedBy === userId || combatant.ownedBy === DM_PLAYER_GMPC_ID);
            const isStunned = (combatant.activeEffects || []).some(e => e.name === 'stunned');

            if (!isMyTurn || isStunned) {
                container.innerHTML = `<p class="text-center text-gray-400">Waiting for turn...</p>${isStunned ? '<p class="text-center text-red-400 font-bold mt-1">STUNNED!</p>' : ''}`;
                return;
            }

            if (battleActionState.step === 'targeting') {
                const ability = battleActionState.selectedAbility;
                
                let details = '';
                if (ability.type === 'attack' || ability.type === 'splash') {
                    details = `Dmg: ${ability.damageRange[0]}-${ability.damageRange[1]} (${ability.hitChance}% chance)`;
                } else if (ability.type === 'heal') {
                    details = `Heal: ${ability.healRange[0]}-${ability.healRange[1]}`;
                } else if (ability.type === 'dot' || ability.type === 'hot') {
                    const dmg = ability.damageRange[0] === ability.damageRange[1] ? ability.damageRange[0] : `${ability.damageRange[0]}-${ability.damageRange[1]}`;
                    const type = ability.type === 'dot' ? 'Dmg/T' : 'Heal/T';
                    details = `Tick: ${dmg} ${type} (${ability.duration}T)`;
                } else if (ability.type === 'status') {
                    details = `Applies **${ability.statusName}** (${ability.duration}T) (${ability.hitChance}% chance)`;
                }

                const targetPrompt = document.createElement('div');
                targetPrompt.className = 'text-center flex-shrink-0';
                targetPrompt.innerHTML = `
                    <p class="text-xs text-yellow-400">SELECT TARGET</p>
                    <p class="font-bold text-base">${ability.name}</p>
                    <p class="text-xs text-gray-300 mt-1">${details}</p>
                `;
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.className = 'gruvhub-button text-xs p-1 mt-2 w-full';
                cancelBtn.dataset.action = 'cancel-targeting';
                targetPrompt.appendChild(cancelBtn);
                container.appendChild(targetPrompt);
            } else if (battleActionState.step === 'abilities') { // Show abilities list
                // Inner container for abilities only
                const abilitiesGrid = document.createElement('div');
                abilitiesGrid.id = 'ability-buttons-grid'; // Use the dedicated grid ID
                abilitiesGrid.className = 'grid grid-cols-4 gap-2 w-full flex-grow overflow-y-auto pr-1'; 
                
                (combatant.abilities || []).forEach((ability, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'gruvhub-button p-2 text-sm truncate';
                    btn.textContent = ability.name;
                    btn.title = ability.name; // Use title for full name on hover
                    btn.dataset.action = 'select-ability';
                    btn.dataset.abilityIndex = index;
                    abilitiesGrid.appendChild(btn);
                });
                
                const backBtn = document.createElement('button');
                backBtn.textContent = 'Back';
                backBtn.className = 'gruvhub-button text-xs p-1 mt-2 flex-shrink-0 col-span-4'; 
                backBtn.dataset.action = 'show-main-menu';
                
                // Append the entire grid and the back button to the main container
                container.appendChild(abilitiesGrid);
                container.appendChild(backBtn);
            } else { // Show main menu
                container.innerHTML = `
                    <div class="flex flex-col gap-2">
                        <button class="gruvhub-button p-2" data-action="show-abilities">Abilities</button>
                        <button class="gruvhub-button p-2" data-action="end-turn">End Turn</button>
                    </div>
                `;
            }
        }
        
        function handleBattleAction(e) {
            const action = e.target.dataset.action;
            if (!action) return;

            const combatant = vttState.battle.combatants[vttState.battle.turnIndex];
            const isMyTurn = (isDM || combatant.ownedBy === userId || combatant.ownedBy === DM_PLAYER_GMPC_ID);
            if (!isMyTurn) return;

            switch(action) {
                case 'show-abilities':
                    battleActionState.step = 'abilities';
                    render();
                    break;
                case 'show-main-menu':
                case 'cancel-targeting':
                    battleActionState = { step: 'main', selectedAbility: null };
                    render();
                    break;
                case 'select-ability':
                    const abilityIndex = parseInt(e.target.dataset.abilityIndex, 10);
                    battleActionState.selectedAbility = combatant.abilities[abilityIndex];
                    battleActionState.step = 'targeting';
                    render();
                    break;
                case 'end-turn':
                    executeAbility(combatant, null, null); // Pass null ability to just advance turn
                    break;
            }
        }

        function updateTargetingUI(currentCombatant) {
            document.querySelectorAll('.combatant-card').forEach(card => {
                card.classList.remove('targetable');
                if (battleActionState.step === 'targeting') {
                    const targetId = card.dataset.id;
                    const targetCombatant = vttState.battle.combatants.find(c => c.id === targetId);
                    if (!targetCombatant || targetCombatant.isDefeated) return;
                    
                    // A token is on the Player Team if ownedBy is NOT 'dm'
                    const isTargetPlayer = targetCombatant.ownedBy !== 'dm';
                    const isAttackerPlayer = currentCombatant.ownedBy !== 'dm';
                    const abilityType = battleActionState.selectedAbility.type;

                    if (abilityType === 'attack' || abilityType === 'splash' || abilityType === 'dot' || abilityType === 'status') {
                        // Attacks/DoT/Status target enemies (opposite team)
                        if (isTargetPlayer !== isAttackerPlayer) {
                            card.classList.add('targetable');
                        }
                    } else if (abilityType === 'heal' || abilityType === 'hot') {
                        // Heals/HoT target allies (same team)
                        if (isTargetPlayer === isAttackerPlayer) {
                            card.classList.add('targetable');
                        }
                    }
                }
            });
        }
        
        function handleTargetSelection(e) {
            if (battleActionState.step !== 'targeting') return;
            const card = e.target.closest('.combatant-card');
            if (!card || !card.classList.contains('targetable')) return;

            const targetId = card.dataset.id;
            const attacker = vttState.battle.combatants[vttState.battle.turnIndex];
            const target = vttState.battle.combatants.find(c => c.id === targetId);
            
            executeAbility(attacker, target, battleActionState.selectedAbility);
        }

        function playBattleAnimation(targetId, animationType) {
            const card = document.querySelector(`#battle-screen .combatant-card[data-id="${targetId}"]`);
            if (!card) return;

            const rect = card.getBoundingClientRect();
            const effectEl = document.createElement('div');
            effectEl.className = `spell-effect on-battle effect-${animationType}`;
            effectEl.style.left = `${rect.left + rect.width / 2}px`;
            effectEl.style.top = `${rect.top + rect.height / 2}px`;
            
            document.body.appendChild(effectEl);
            setTimeout(() => { effectEl.remove(); }, 1500); // Increased duration
        }


        function executeAbility(attacker, target, ability) {
            const updatedBattle = JSON.parse(JSON.stringify(vttState.battle));
            const attackerCombatant = updatedBattle.combatants.find(c => c.id === attacker.id);

            if (ability) {
                const targetCombatant = updatedBattle.combatants.find(c => c.id === target.id);
                let logText = '';
                
                // Base chance to hit for attacks/status/DoT/HoT
                const hitRoll = Math.floor(Math.random() * 100) + 1;
                const isHit = ability.type === 'heal' || ability.type === 'hot' || hitRoll <= (ability.hitChance || 100);

                if (ability.type === 'attack' || ability.type === 'splash') {
                    if (isHit) {
                        const damage = Math.floor(Math.random() * (ability.damageRange[1] - ability.damageRange[0] + 1)) + ability.damageRange[0];
                        targetCombatant.currentHP = Math.max(0, targetCombatant.currentHP - damage);
                        if(ability.animation) playBattleAnimation(targetCombatant.id, ability.animation);
                        logText = `üí• ${attackerCombatant.name}'s ${ability.name} hits ${targetCombatant.name} for ${damage} damage!`;
                        
                        // Handle splash damage
                        if (ability.type === 'splash') {
                            const splashDamage = Math.floor(damage / 2);
                            const targetIsPlayer = targetCombatant.ownedBy !== 'dm';
                            updatedBattle.combatants.forEach((secondaryTarget) => {
                                const secondaryIsPlayer = secondaryTarget.ownedBy !== 'dm';
                                if (secondaryTarget.id !== targetCombatant.id && !secondaryTarget.isDefeated && secondaryIsPlayer === targetIsPlayer) {
                                    secondaryTarget.currentHP = Math.max(0, secondaryTarget.currentHP - splashDamage);
                                    if(ability.animation) setTimeout(() => playBattleAnimation(secondaryTarget.id, ability.animation), 200);
                                    logText += ` ${secondaryTarget.name} takes ${splashDamage} splash damage.`;
                                    if (secondaryTarget.currentHP <= 0) secondaryTarget.isDefeated = true;
                                }
                            });
                        }
                    } else {
                        logText = `üí® ${attackerCombatant.name}'s ${ability.name} misses ${targetCombatant.name}!`;
                    }
                } else if (ability.type === 'heal') {
                    const healing = Math.floor(Math.random() * (ability.healRange[1] - ability.healRange[0] + 1)) + ability.healRange[0];
                    targetCombatant.currentHP = Math.min(targetCombatant.maxHp, targetCombatant.currentHP + healing);
                    if(ability.animation) playBattleAnimation(targetCombatant.id, ability.animation);
                    logText = `‚ú® ${attackerCombatant.name} uses ${ability.name} to heal ${targetCombatant.name} for ${healing} HP.`;
                } else if (ability.type === 'dot' || ability.type === 'hot' || ability.type === 'status') {
                    if (isHit) {
                        // Status/DoT/HoT application logic
                        const effectName = ability.statusName || ability.name;
                        const duration = ability.duration || 1;
                        
                        let existingEffectIndex = (targetCombatant.activeEffects || []).findIndex(e => e.name === effectName);

                        if (existingEffectIndex !== -1) {
                            // If effect already exists, refresh duration
                            targetCombatant.activeEffects[existingEffectIndex].duration = duration;
                        } else {
                            // Apply new effect
                            const newEffect = {
                                name: effectName,
                                type: ability.type,
                                duration: duration,
                                damageRange: ability.damageRange || [0, 0], // used for dot/hot tick
                            };
                            if (!targetCombatant.activeEffects) targetCombatant.activeEffects = [];
                            targetCombatant.activeEffects.push(newEffect);
                        }

                        if(ability.animation) playBattleAnimation(targetCombatant.id, ability.animation);
                        
                        logText = `‚úÖ ${attackerCombatant.name}'s ${ability.name} applies **${effectName}** to ${targetCombatant.name} for ${duration} turns!`;

                    } else {
                         logText = `üí® ${attackerCombatant.name}'s ${ability.name} fails to apply its effect on ${targetCombatant.name}.`;
                    }
                }

                // Check for defeat after direct damage
                if (targetCombatant.currentHP <= 0) {
                    targetCombatant.isDefeated = true;
                    logText += ` ${targetCombatant.name} has been defeated!`;
                }
                
                updatedBattle.log.push({ text: logText, type: 'battle' });
            } else {
                 // Only log end turn if it was an active turn, not an auto-advance due to stun/defeat processing
                 if (!attackerCombatant.isDefeated && !(attackerCombatant.activeEffects || []).some(e => e.name === 'stunned')) {
                      updatedBattle.log.push({ text: `${attackerCombatant.name} ends their turn.`, type: 'system' });
                 }
            }

            battleActionState = { step: 'main', selectedAbility: null };
            
            // Check win/loss condition after turn resolution
            const playerTeamDefeated = updatedBattle.combatants.filter(c => c.ownedBy !== 'dm').every(c => c.isDefeated);
            const enemyTeamDefeated = updatedBattle.combatants.filter(c => c.ownedBy === 'dm').every(c => c.isDefeated);
            
            if (playerTeamDefeated || enemyTeamDefeated) {
                const message = playerTeamDefeated ? "DEFEAT" : "VICTORY!";
                updatedBattle.log.push({ text: `Battle over! ${message}`, type: 'system' });
                showBattleEndMessage(message);
                updateDoc(vttDocRef, { battle: updatedBattle }); 
                setTimeout(endBattle, 3000);
                return;
            }

            // Reset turn processing flag for the combatant whose turn is coming up
            const nextIndex = (updatedBattle.turnIndex + 1) % updatedBattle.combatants.length;
            updatedBattle.combatants[nextIndex].needsProcessing = true;

            // Advance turn, skipping defeated characters
            let newNextIndex = nextIndex;
            while(updatedBattle.combatants[newNextIndex].isDefeated) {
                newNextIndex = (newNextIndex + 1) % updatedBattle.combatants.length;
            }
            updatedBattle.turnIndex = newNextIndex;
            updatedBattle.turnTimerStartTime = serverTimestamp(); // Reset timer stamp

            updateDoc(vttDocRef, { battle: updatedBattle });
        }
        
        function endBattle() {
            // FIX 1: This is the actual function to end the battle and save final HP/clear state.
            const finalCombatants = vttState.battle.combatants;
            const updatedMaps = JSON.parse(JSON.stringify(vttState.maps));
            
            finalCombatants.forEach(combatant => {
                for (const map of updatedMaps) {
                    const token = map.tokens.find(t => t.id === combatant.id);
                    if (token) {
                        token.hp = combatant.isDefeated ? 0 : combatant.currentHP;
                        // Clear battle effects/stats on token before saving back
                        token.activeEffects = [];
                        break;
                    }
                }
            });

            updateDoc(vttDocRef, {
                maps: updatedMaps,
                battle: DEFAULT_STATE.battle 
            });

            if (battleTimerInterval) { // Clear client-side interval
                clearInterval(battleTimerInterval);
                battleTimerInterval = null;
            }
        }
        
        function showBattleEndMessage(message) {
            const msgContainer = document.getElementById('battle-end-message');
            msgContainer.querySelector('h2').textContent = message;
            msgContainer.classList.remove('hidden');
        }

        // Stat Block Abilities
        function renderAbilitiesInStatBlock(abilities) {
            const listEl = document.getElementById('stat-block-abilities-list');
            listEl.innerHTML = '';
            if (!abilities || abilities.length === 0) {
                listEl.innerHTML = '<p class="text-xs text-gray-400 text-center">No abilities defined.</p>';
                return;
            }
            abilities.forEach((ability, index) => {
                const abilityEl = document.createElement('div');
                abilityEl.className = 'text-xs bg-[#3a241d] p-2 rounded flex justify-between items-center';
                
                let details = '';
                const levelDisplay = `L${ability.level || 1}`; // Ensure level defaults if missing

                if (ability.type === 'attack' || ability.type === 'splash') {
                    details = `${levelDisplay}, ${ability.hitChance}% Hit, ${ability.damageRange[0]}-${ability.damageRange[1]} Dmg`;
                } else if (ability.type === 'heal') {
                    details = `${levelDisplay}, ${ability.healRange[0]}-${ability.healRange[1]} Heal`;
                } else if (ability.type === 'dot' || ability.type === 'hot') {
                    const dmg = ability.damageRange[0] === ability.damageRange[1] ? ability.damageRange[0] : `${ability.damageRange[0]}-${ability.damageRange[1]}`;
                    const type = ability.type === 'dot' ? 'DoT' : 'HoT';
                    details = `${levelDisplay}, ${ability.hitChance}% Hit, ${dmg} ${type} (${ability.duration}T)`;
                } else if (ability.type === 'status') {
                     details = `${levelDisplay}, ${ability.hitChance}% Hit, Applies ${ability.statusName} (${ability.duration}T)`;
                }

                abilityEl.innerHTML = `<div><strong>${ability.name}</strong> (${ability.type})<br><span class="text-gray-400">${details}</span></div>`;
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '&times;';
                deleteBtn.className = 'text-red-400 hover:text-red-200 font-bold text-lg px-1';
                deleteBtn.onclick = () => removeAbilityFromStatBlock(index);
                abilityEl.appendChild(deleteBtn);
                listEl.appendChild(abilityEl);
            });
        }

        function addAbilityToStatBlock() {
            const tokenId = document.getElementById('stat-block-modal').dataset.tokenId;
            if (!tokenId) return;

            const name = document.getElementById('ability-name').value;
            const type = document.getElementById('ability-type').value;
            const level = parseInt(document.getElementById('ability-level').value, 10) || 1; // NEW: Get Level
            const hitChance = parseInt(document.getElementById('ability-hitchance').value, 10);
            const min = parseInt(document.getElementById('ability-damage-min').value, 10);
            const max = parseInt(document.getElementById('ability-damage-max').value, 10);
            const animation = document.getElementById('ability-animation').value;
            const duration = parseInt(document.getElementById('ability-duration').value, 10);
            const statusName = document.getElementById('ability-status-select').value;
            
            if (!name || isNaN(min) || isNaN(max)) {
                showModal("Input Error", "Please fill out ability name and tick damage/heal range.", ()=>{});
                return;
            }
            if ((type === 'dot' || type === 'hot' || type === 'status') && (!duration || isNaN(duration) || duration < 1)) {
                 showModal("Input Error", "Duration must be 1 turn or more for continuous effects.", ()=>{});
                 return;
            }
            if (type === 'status' && !statusName) {
                 showModal("Input Error", "Please select a status effect.", ()=>{});
                 return;
            }


            const newAbility = { name, type, animation: animation || null, hitChance: hitChance || 100, level };
            
            if (type === 'attack' || type === 'splash') {
                 newAbility.damageRange = [min, max];
            } else if (type === 'heal') {
                 newAbility.healRange = [min, max];
            } else if (type === 'dot' || type === 'hot') {
                 newAbility.damageRange = [min, max];
                 newAbility.duration = duration;
                 newAbility.statusName = name; // Use ability name as status effect name for DoT/HoT
            } else if (type === 'status') {
                 newAbility.statusName = statusName;
                 newAbility.duration = duration;
                 newAbility.hitChance = hitChance || 100;
            }
            
            const map = getActiveMap();
            const token = map.tokens.find(t => t.id === tokenId);
            if (!token.abilities) token.abilities = [];
            token.abilities.push(newAbility);

            updateDoc(vttDocRef, { maps: vttState.maps });
        }

        function removeAbilityFromStatBlock(index) {
            const tokenId = document.getElementById('stat-block-modal').dataset.tokenId;
            if (!tokenId) return;
            const map = getActiveMap();
            const token = map.tokens.find(t => t.id === tokenId);
            if (token && token.abilities) {
                token.abilities.splice(index, 1);
                updateDoc(vttDocRef, { maps: vttState.maps });
            }
        }

        // --- NEW DM ABILITY LIBRARY LOGIC ---

        function getAllAbilities() {
            const abilities = [];
            Object.values(DEFAULT_STATE.presetTokens).forEach(category => {
                category.forEach(token => {
                    (token.abilities || []).forEach(ability => {
                        // Ensure a unique ID (by stringifying the object) before adding to list
                        abilities.push({...ability, sourceToken: token.name, uid: JSON.stringify(ability)});
                    });
                });
            });
            // Filter unique abilities
            const seen = new Set();
            return abilities.filter(ability => {
                const isDuplicate = seen.has(ability.uid);
                seen.add(ability.uid);
                return !isDuplicate;
            }).sort((a, b) => (a.level || 1) - (b.level || 1));
        }

        function openAbilityLibrary() {
            document.getElementById('ability-library-modal').classList.remove('hidden');
            renderAbilityLibrary();
        }

        function closeAbilityLibrary() {
            document.getElementById('ability-library-modal').classList.add('hidden');
        }

        function renderAbilityLibrary() {
            const libraryList = document.getElementById('ability-library-list');
            const levelFilter = parseInt(document.getElementById('ability-library-level-filter').value, 10);
            const searchInput = document.getElementById('ability-library-search').value.toLowerCase();
            libraryList.innerHTML = '';

            const allAbilities = getAllAbilities();

            const filteredAbilities = allAbilities.filter(ability => {
                const passesLevel = levelFilter === 0 || (ability.level || 1) === levelFilter;
                const passesSearch = ability.name.toLowerCase().includes(searchInput) || ability.type.toLowerCase().includes(searchInput);
                return passesLevel && passesSearch;
            });

            if (filteredAbilities.length === 0) {
                libraryList.innerHTML = '<p class="text-gray-400 text-center p-4">No abilities found matching the filter.</p>';
                return;
            }

            filteredAbilities.forEach(ability => {
                const abilityEl = document.createElement('div');
                // Store the full JSON string on the element for easy retrieval
                abilityEl.dataset.abilityData = JSON.stringify(ability);
                abilityEl.className = 'gruvhub-bg gruvhub-border p-3 rounded-lg flex justify-between items-center cursor-pointer hover:border-yellow-400 transition-all';
                
                let details = '';
                if (ability.type === 'attack' || ability.type === 'splash') {
                    details = `Hit: ${ability.hitChance}%, Dmg: ${ability.damageRange[0]}-${ability.damageRange[1]}`;
                } else if (ability.type === 'heal') {
                    details = `Heal: ${ability.healRange[0]}-${ability.healRange[1]}`;
                } else if (ability.type === 'dot' || ability.type === 'hot') {
                    const dmg = ability.damageRange[0] === ability.damageRange[1] ? ability.damageRange[0] : `${ability.damageRange[0]}-${ability.damageRange[1]}`;
                    const type = ability.type === 'dot' ? 'DoT' : 'HoT';
                    details = `${ability.hitChance}% Hit, ${dmg} ${type} (${ability.duration}T)`;
                } else if (ability.type === 'status') {
                    details = `${ability.hitChance}% Hit, Status: ${ability.statusName} (${ability.duration}T)`;
                }

                abilityEl.innerHTML = `
                    <div>
                        <strong class="text-white text-base">${ability.name}</strong> 
                        <span class="text-xs ml-2 py-0.5 px-2 rounded-full bg-blue-800 text-white">${ability.type.toUpperCase()}</span>
                        <p class="text-sm text-gray-300 mt-1">${details}</p>
                        <p class="text-xs text-gray-500 mt-1">Source: ${ability.sourceToken}</p>
                    </div>
                    <div class="flex flex-col items-center">
                        <span class="text-2xl font-bold text-yellow-300">L${ability.level || 1}</span>
                        <button class="gruvhub-button text-xs py-1 px-3 mt-1" data-action="add-ability">Add</button>
                    </div>
                `;
                libraryList.appendChild(abilityEl);
            });
        }

        function handleAbilitySelectFromLibrary(e) {
            // Check if the click was directly on the 'Add' button
            if (e.target.dataset.action === 'add-ability') {
                // Find the closest ancestor element where the ability JSON is stored
                const abilityEl = e.target.closest('[data-ability-data]'); 
                if (!abilityEl) return;

                // FIX: Retrieve JSON from dataset and parse
                const abilityData = JSON.parse(abilityEl.dataset.abilityData);

                const tokenId = document.getElementById('stat-block-modal').dataset.tokenId;
                if (!tokenId) return;

                // Remove temporary keys used for unique identification
                delete abilityData.uid;
                delete abilityData.sourceToken;
                
                // Add the ability to the selected token
                const map = getActiveMap();
                const token = map.tokens.find(t => t.id === tokenId);
                if (!token.abilities) token.abilities = [];
                token.abilities.push(abilityData);

                updateDoc(vttDocRef, { maps: vttState.maps })
                    .then(() => {
                        // Keep stat block open, but close the library
                        closeAbilityLibrary(); 
                        // Re-open stat block to show the newly added ability
                        showStatBlock(token);
                    });
            }
        }
        // --- END NEW DM ABILITY LIBRARY LOGIC ---

    </script>
</body>
</html>
